Section Header

  + name := ITM_EXPR_WRITE;

Section Inherit

  + parent_itm_expr :Expanded ITM_EXPR;

Section Public

  - is_void :BOOLEAN <- FALSE;
  
  + affect :ITM_AFFECT;
  
  + slot_name :CSTRING;
  
  + expr :ITM_EXPR;
  
  - has_results :BOOLEAN <- TRUE;

  + result :EXPR := EXPR;

  - compile_in list:LIST :SELF <-
  [ -? { list.self != NULL }; ]
  ( + slot :SLOT;
    + local :ITM_LOCAL;
    
    // affect result is the expression
    result := expr.compile_in list.result;
  
    // Affect
    ((local := lookup_local slot_name) != NULL).if {
      // Local variable
      local.write result in list.if_fail { e:ERR;
        err := e;
      };
    } else {
      slot := list.self.type.prototype.find_slot slot_name;
      (slot = NULL).if {
        err := error(err, position, "Cannot find slot " + slot_name + " in " + pretty_type(list.self.type));
        err := error(err, position, "Discarding write");
      }.elseif {! slot.slot_data} then {
        err := error(err, position, "Cannot write into slot " + slot_name + " in " + pretty_type(list.self.type) + ": is not a data slot");
        err := error(err, position, "Discarding write");
      } else {
        + r :REG;
        slot.shared.if {
          r := slot.shared_data_variable;
        } else {
          r := INSTR_GETELEMPTR
            .clone
            .make (list.self) slot slot
            .add_in list
            .result;
        };
        INSTR_STORE
          .clone
          .make_store_in r value result
          .add_in list;
      };
    };
    Self
  );

Section PARSER

  - make_affect a:ITM_AFFECT in var:CSTRING of e:ITM_EXPR :SELF <-
  (
    e.set_itm_parent Self;
    affect    := a;
    slot_name := var;
    expr      := e;
    Self
  );
  

