Section Header

  + name      := PARSER;

Section Inherit

  + parent_any :Expanded ANY;

Section SELF

  + filename :CSTRING := "";
  + source :STRING;
  + position :INTEGER;
  + line :INTEGER;
  + column :INTEGER;
  
  - print_warning <-
  (
    "Warning: ".print; filename.print; ":".print; line.print; ":".print; column.print; ": ".print;
  );
  
  - character i:INTEGER :CHARACTER <-
  ( + c:CHARACTER;
    source.valid_index (position+i).if {
      c := source.item (position+i);
    } else {
      c := 0.to_character;
    };
    c
  );
  
  - last_character :CHARACTER <-
    character 0;
  
  - read_character :CHARACTER <-
  (
    source.valid_index position.if {
      position := position + 1;
      (character (-1) = '\n').if {
        line := line + 1;
        column := 1;
      } else {
        column := column + 1;
      };
    };
    last_character
  );
  
  - read_characters n:INTEGER <-
  (
    (n > 0).if {
      read_character;
      read_characters (n-1);
    };
  );
  
  - read_maybe str:ABSTRACT_STRING :BOOLEAN <-
  ( + i:INTEGER;
    + res :BOOLEAN;
    i := str.lower;
    {(i <= str.upper) && {character (i - str.lower) = str.item i}}.while_do {
      i := i + 1;
    };
    res := (i > str.upper);
    res.if {
      read_characters (str.count);
    };
    res
  );

  - read_always str:ABSTRACT_STRING <-
  (
    read_maybe str.if_false {
      print_warning;
      "expected \"".print; str.print; "\"".println;
    };
  );
  
  - read_spaces <-
  (
    {(last_character = 0.to_character) || {last_character > ' '}}.until_do {
      read_character;
    };
  );
  
  //-- style -> [+-]
  
  + last_style :ITM_STYLE;
  
  - read_style :ITM_STYLE <-
  (
    last_style := ITM_STYLE.clone.make last_character;
    last_style.valid.if {
      position := position + 1;
    };
    last_style
  );
  
  //-- affect -> ":=" | "?=" | "<-"
  
  + last_affect :ITM_AFFECT;
  
  - read_affect :ITM_AFFECT <-
  (
    read_maybe ":=".if {
      last_affect := ITM_AFFECT.clone.make ':';
    }.elseif {read_maybe "<-"} then {
      last_affect := ITM_AFFECT.clone.make '<';
    }.elseif {read_maybe "?="} then {
      last_affect := ITM_AFFECT.clone.make '?';
    } else {
      last_affect := ITM_AFFECT.clone.make (0.to_character);
    };
    last_affect
  );
  
  //-- identifier -> [a-zA-Z_][a-zA-Z0-9_]*
  
  + last_identifier :STRING := STRING.create 64;
  
  - read_identifier :BOOLEAN <-
  ( + res:BOOLEAN;
    last_identifier.clear;
    last_character.is_digit.if_false {
      {(last_character.is_lower) ||
       {last_character.is_digit} ||
       {last_character = '_'}
      }.while_do {
        res := TRUE;
        last_identifier.add_last last_character;
        read_character;
      };
    };
    res
  );
  
  //-- keyword -> [A-Z][a-z0-9_]*
  
  + last_keyword :STRING := STRING.create 64;
  
  - read_keyword :BOOLEAN <-
  ( + res:BOOLEAN;
    last_keyword.clear;
    ((character 0.is_upper) && {character 1.is_lower}).if {
      res := TRUE;
      last_keyword.add_last last_character;
      read_character;
      {(last_character.is_lower) ||
       {last_character.is_digit} ||
       {last_character = '_'}
      }.while_do {
        last_keyword.add_last last_character;
        read_character;
      };
    };
    res
  );
  
  //-- cap_identifier -> [A-Z][A-Z0-9_]*
  
  + last_cap_identifier :STRING := STRING.create 64;
  
  - read_cap_identifier :BOOLEAN <-
  ( + res:BOOLEAN;
    last_cap_identifier.clear;
    (last_character.is_upper).if {
      res := TRUE;
      {(last_character.is_upper) ||
       {last_character.is_digit} ||
       {last_character = '_'}
      }.while_do {
        last_cap_identifier.add_last last_character;
        read_character;
      };
    };
    res
  );
  
  //-- string -> '"' string_content* '"'
  //-- string_content -> [^"] | '""'
  
  + last_string :STRING := STRING.create 128;
  
  - read_string :BOOLEAN <-
  ( + result :BOOLEAN;
    last_string.clear;
    (last_character = '"').if {
      read_character;
      read_string_content;
      read_always "\"";
      result := TRUE;
    };
    result
  );
  
  - read_string_content <-
  (
    ((character 0 = '"') && {character 1 = '"'}).if {
      last_string.add_last '"';
      read_character;
      read_character;
      read_string_content;
    }.elseif {last_character != '"'} then {
      last_string.add_last last_character;
      read_character;
      read_string_content;
    };
  );
  
  //-- symbol -> '`' symbol_content* '`'
  //-- symbol_content -> [^"] | '""'
  
  + last_symbol :STRING := STRING.create 128;
  
  - read_symbol :BOOLEAN <-
  ( + result :BOOLEAN;
    last_string.clear;
    (last_character = '`').if {
      read_character;
      read_symbol_content;
      read_always "`";
      result := TRUE;
    };
    result
  );
  
  - read_symbol_content <-
  (
    ((character 0 = '`') && {character 1 = '`'}).if {
      last_symbol.add_last '`';
      read_character;
      read_character;
      read_symbol_content;
    }.elseif {last_character != '`'} then {
      last_symbol.add_last last_character;
      read_character;
      read_symbol_content;
    };
  );
  
  //++ PROTOTYPE -> cap_identifier
  
  - read_prototype :ITM_EXPR_PROTO <-
  ( + res :ITM_EXPR_PROTO;
    read_cap_identifier.if {
      res := ITM_EXPR_PROTO.clone.make last_cap_identifier;
    };
    res
  );
  
  //++ SECTION_HEADER -> . "Section" "Header" H_SLOTS
  
  - read_section_header <-
  (
    read_spaces;
    read_always "Section";
    read_spaces;
    read_always "Header";
    read_h_slots;
  );
  
  //++ H_SLOTS -> C_SLOT*
  
  - read_h_slots <-
  ( + slot :ITM_SLOT;
  
    ((slot := read_c_slot) != NULL).if {
      hook_header_slot slot;
      read_h_slots;
    };
  );
  
  - hook_header_slot slot:ITM_SLOT;
  
  //++ KEYWORDS -> keyword*
  
  - read_keywords :ITM_KEYWORDS <-
  ( + keywords:ITM_KEYWORDS;
    
    read_spaces;
    read_keyword.if {
      keywords := ITM_KEYWORDS.clone.make;
      keywords.add_keyword last_keyword;
      read_keywords_in keywords;
    };
    keywords
  );
  
  - read_keywords_in keywords:ITM_KEYWORDS :ITM_KEYWORDS <-
  (
    read_spaces;
    read_keyword.if {
      keywords.add_keyword last_keyword;
      read_keywords_in keywords;
    };
    keywords
  );
  
  //++ SECTIONS -> SECTION*
  
  - read_sections <-
  (
    read_section.if {
      read_sections;
    };
  );
  
  //++ SECTION -> "Section" . "Public" SECTION_CODE
  
  - read_section :BOOLEAN <-
  ( + res:BOOLEAN;
    + sec :ITM_SECTION;
  
    read_spaces;
    read_maybe "Section".if {
      sec := ITM_SECTION.clone.make;
      read_spaces;
      read_always "Public";
      read_spaces;
      res := TRUE;
      read_section_code sec;
    };
    res
  );
  
  //++ SECTION_CODE -> C_SLOTS
  
  - read_section_code sec:ITM_SECTION <-
  (
    read_c_slots sec;
  );

  //++ C_SLOTS -> C_SLOT*
  
  - read_c_slots sec:ITM_SECTION <-
  ( + slot :ITM_SLOT;
    ((slot := read_c_slot) != NULL).if {
      slot.set_section sec;
      handle_slot slot;
      read_c_slots sec;
    };
  );

  //++ C_SLOT -> style . identifier C_ARG? (affect keyword* EXPR)? ";"
  
  - read_c_slot :ITM_SLOT <-
  ( + slot :ITM_SLOT;
    + style :ITM_STYLE;
    + affect :ITM_AFFECT;
    + key :ITM_KEYWORDS;
    + expr :ITM_EXPR;
    + ident :CSTRING;
    
    read_spaces;
    style := read_style;
    style.valid.if {
      slot := ITM_SLOT.clone.make;
      slot.set_style style;
      read_spaces;
      read_identifier.if {
        slot.add_identifier last_identifier;
      };
      read_spaces;
      read_c_arg slot;
      read_spaces;
      affect := read_affect;
      affect.valid.if {
        ((key := read_keywords) != NULL).if {
          slot.set_keywords key;
        };
        slot.set_expression read_expr;
      };
      read_always ";";
    };
    slot
  );
  
  - handle_slot slot:ITM_SLOT;
  
  //++ C_ARG -> identifier . ":" PROTOTYPE
  
  - read_c_arg slot:ITM_SLOT :BOOLEAN <-
  ( + res :BOOLEAN;
    + idf :CSTRING;
    + type :ITM_EXPR_PROTO;
  
    read_identifier.if {
      read_spaces;
      idf := last_identifier;
      read_always ":";
      type := read_prototype;
      (type = NULL).if {
        print_warning;
        "Expected prototype".println;
      } else {
        slot.add_argument (idf, type);
      };
    };
    res
  );
  
  //++ EXPR -> symbol
  //++       | string
  //++       | PROTOTYPE
  //++       | "(" GROUP ")"
  //++       | identifier EXPR?
  
  - read_expr :ITM_EXPR <-
  ( + res :ITM_EXPR;
    + proto :ITM_EXPR_PROTO;
    res := ITM_EXPR_VOID;
    
    read_symbol.if {
      res := ITM_EXPR_SYM.clone.make last_symbol;
    }.elseif {read_string} then {
      res := ITM_EXPR_STR.clone.make last_string;
    }.elseif {(proto := read_prototype) != NULL} then {
      res := proto;
    }.elseif {last_character = '('} then {
      read_always "(";
      read_spaces;
      res := read_group;
      read_always ")";
    }.elseif {read_identifier} then {
      + expr :ITM_EXPR;
      + idf :CSTRING;
      idf := last_identifier;
      read_spaces;
      expr := read_expr;
      res := ITM_EXPR_READ.clone.make (idf, expr);
    };
    res
  );
  
  //++ GROUP -> INSTS
  
  - read_group :ITM_EXPR_GROUP <-
  ( + res :ITM_EXPR_GROUP;
    res := ITM_EXPR_GROUP.clone.make;
    read_insts res;
    res
  );
  
  //++ INSTS -> INST*
  
  - read_insts group:ITM_EXPR_GROUP <-
  ( + inst :ITM_INST;
    ((inst := read_inst) != NULL).if {
      group.add_inst inst;
      read_insts group;
    };
  );
  
  //++ INST -> EXPR ";"
  
  - read_inst :ITM_INST <-
  ( + expr :ITM_EXPR;
    + res :ITM_INST;
  
    read_spaces;
    expr := read_expr;
    expr.is_void.if_false {
      read_spaces;
      read_always ";";
      res := ITM_INST_EXPR.clone.make expr;
    };
    res
  );
  
  - open_source f:ABSTRACT_STRING <-
  ( + file:POINTER;
    + sz:INTEGER;

    filename := f;
    file := LIBC.fopen (f.to_external, "rb".to_external);
    sz := LIBC.file_size file;
    source := STRING.create (sz+1);
    LIBC.fread (source.storage, 1, sz, file);
    LIBC.fclose file;
    source.from_external (source.storage);
    position := source.lower;
    line := 1;
    column := 1;
  );

