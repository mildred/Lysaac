Section Header

  + name      := PARSER;

Section Inherit

  + parent_any :Expanded ANY;

Section SELF

  + filename :CSTRING := "";
  + source :STRING;
  + position_index :INTEGER;
  + line :INTEGER;   // references next_char
  + column :INTEGER; // references next_char
  + error_stack :ERR;
  
  - position :POS <- POS.create (filename, line, column);
  
  - warning s:ABSTRACT_STRING <- warning s in position;
  
  - warning s:ABSTRACT_STRING in p:POS <-
  (
    STD_ERROR.put_string (p.to_string);
    STD_ERROR.put_string ": ";
    STD_ERROR.put_string s;
    STD_ERROR.put_string "\n";
    error_stack := ERR.create s position p parent error_stack;
  );
  
  - character i:INTEGER :CHARACTER <-
  ( + c:CHARACTER;
    source.valid_index (position_index+i).if {
      c := source.item (position_index+i);
    } else {
      c := 0.to_character;
    };
    c
  );
  
  - last_character :CHARACTER <-
    character 0;
  
  - read_character :CHARACTER <-
  (
    source.valid_index position_index.if {
      position_index := position_index + 1;
      (character (0) = '\n').if {
        line := line + 1;
        column := 1;
      } else {
        column := column + 1;
      };
    };
    last_character
  );
  
  - read_characters n:INTEGER <-
  (
    (n > 0).if {
      read_character;
      read_characters (n-1);
    };
  );
  
  - read_maybe str:ABSTRACT_STRING :BOOLEAN <- read_maybe str if {TRUE};
  - read_maybe str:ABSTRACT_STRING except not:ABSTRACT_STRING :BOOLEAN <-
    read_maybe str unless { is_at not };
  - read_maybe str:ABSTRACT_STRING unless condition:{BOOLEAN} :BOOLEAN <-
    read_maybe str if { ! condition.value };
  
  - read_maybe str:ABSTRACT_STRING if condition:{BOOLEAN} :BOOLEAN <-
  ( + res :BOOLEAN;
    res := is_at str;
    (res && condition).if {
      read_characters (str.count);
    } else {
      res := FALSE;
    };
    res
  );
  
  - is_at str:ABSTRACT_STRING :BOOLEAN <-
  ( + i:INTEGER;
    i := str.lower;
    {(i <= str.upper) && {character (i - str.lower) = str.item i}}.while_do {
      i := i + 1;
    };
    i > str.upper
  );

  - read_always str:ABSTRACT_STRING <-
  (
    read_maybe str.if_false {
      warning ("expected \""+str+"\"");
    };
  );
  
  - read_spaces <-
  (
    {(last_character = 0.to_character) || {last_character > ' '}}.until_do {
      read_character;
    };
    ((last_character = '/') && {character 1 = '/'}).if {
      read_line_comment;
    }.elseif {(last_character = '/') && {character 1 = '*'}} then {
      read_nested_comment;
    };
  );
  
  - read_line_comment <-
  (
    ((last_character = '/') && {character 1 = '/'}).if {
      {(last_character = 0.to_character) || {last_character = '\n'} || {last_character = '\r'}}.until_do
      {
        read_character;
      };
    };
    read_spaces;
  );
  
  - read_nested_comment <-
  (
    ((last_character = '/') && {character 1 = '*'}).if {
      {(last_character = 0.to_character) || {(last_character = '*') && {character 1 = '/'}}}.until_do
      {
        read_character;
        ((last_character = '/') && {character 1 = '*'}).if {
          read_nested_comment;
        };
      };
    };
    read_spaces;
  );
  
  //-- style -> [+-]
  
  + last_style :ITM_STYLE;
  
  - read_style :ITM_STYLE <-
  (
    last_style := ITM_STYLE.clone.make last_character;
    last_style.valid.if {
      position_index := position_index + 1;
    };
    last_style
  );
  
  //-- affect -> ":=" | "?=" | "<-"
  
  + last_affect :ITM_AFFECT;
  
  - read_affect :ITM_AFFECT <-
  (
    read_maybe ":=".if {
      last_affect := ITM_AFFECT.clone.make ':';
    }.elseif {read_maybe "<-"} then {
      last_affect := ITM_AFFECT.clone.make '<';
    }.elseif {read_maybe "?="} then {
      last_affect := ITM_AFFECT.clone.make '?';
    } else {
      last_affect := ITM_AFFECT.clone.make (0.to_character);
    };
    last_affect
  );

  //-- integer       -> [0-9a-fA-F_]*
  - read_integer base:INTEGER :(INTEGER, INTEGER) <-
  ( + res :INTEGER;
    + val :INTEGER;
    + shift :INTEGER;

    { (next_char.is_digit)            ||
      {next_char.in_range 'a' to 'f'} ||
      {next_char.in_range 'A' to 'F'} ||
      {next_char = '_'}
    }.while_do {
      read_char;
      (last_char != '_').if {
        val := last_char.hexadecimal_value;
        (val >= base).if {
          warning ("Character '" + last_char.to_string + "' ignored: not allowed in base " + base.to_string);
        } else {
          res   := res * base + val;
          shift := shift + 1;
        };
      };
    };
    res, shift
  );

  //-- num_base      -> 0[xbod]
  //--                | 0([2-9a-fA-F]|1[0-6]):

  - read_num_base :INTEGER <-
  ( + base :INTEGER;
    + c1, c2, c3 :CHARACTER;
    (next_char = '0').if {
      c1 := get_char 2;
      c2 := get_char 3;
      c3 := get_char 4;
      ((c1 = '1') && {c2.in_range '0' to '6'} && {c3 = ':'}).if {
        ? {read_char = '0'};
        ? {read_char = '1'};
        ? {read_char.in_range '0' to '6'};
        base := 10 + last_char.decimal_value;
        ? {read_char = ':'};
        ? {base != 0};
      }.elseif {
        (c2 = ':') &&
        { (c1.in_range '2' to '9') ||
          {c1.in_range 'a' to 'f'} ||
          {c1.in_range 'A' to 'F'} }
      } then {
        ? {read_char = '0'};
        base := read_char.hexadecimal_value;
        ? {read_char = ':'};
        ? {base != 0};
      }.elseif {
        (c1 = 'x') || {c1 = 'b'} || {c1 = 'o'} || {c1 = 'd'}
      } then {
        ? {read_char = '0'};
        read_char
        .when 'b' then { base := 2;  }
        .when 'o' then { base := 8;  }
        .when 'd' then { base := 10; }
        .when 'x' then { base := 16; };
        ? {base != 0};
      };
    };
    base
  );

  //-- num_ext_part  -> [eE][+-]?[0-9][0-9_]*
  - read_num_ext_part :INTEGER <-
  ( + sign   :CHARACTER;
    + res, n :INTEGER;

    ((next_char = 'e') || {next_char = 'E'}).if {
      read_char;
      sign := read_num_sign;
      (res, n) := read_integer 10;
      (sign = '-').if {
        res := -res;
      };
    };

    res
  );
  
  //-- num_unit      -> ([yzafpnumkMGTPEZY]|[MGTPEZY]i)
  //--                  y  is  e-24
  //--                  ...
  //--                  f  is  e-15
  //--                  p  is  e-12
  //--                  n  is  e-9
  //--                  u  is  e-6
  //--                  m  is  e-3
  //--                  k  is  e3       Ki  is  1024
  //--                  M  is  e6       Mi  is  1024^2
  //--                  G  is  e9       Gi  is  1024^3
  //--                  T  is  e12      Ti  is  1024^4
  //--                  P  is  e15      Pi  is  1024^5
  //--                  ...
  //--                  Y  is  e24      Yi  is  1024^8
  //--                  Note: there is no K (with an uppercase K) suffix !!
  - read_num_unit :(INTEGER, INTEGER) <-
  ( + base, exp :INTEGER;
    base := 10;
    exp  := 0;

    next_char
    .when 'y' then { read_char; exp := -24; }
    .when 'z' then { read_char; exp := -21; }
    .when 'a' then { read_char; exp := -18; }
    .when 'f' then { read_char; exp := -15; }
    .when 'p' then { read_char; exp := -12; }
    .when 'n' then { read_char; exp :=  -9; }
    .when 'u' then { read_char; exp :=  -6; }
    .when 'm' then { read_char; exp :=  -3; }
    .when 'k' then { read_char; exp :=   3; }
    .when 'K' then {
      (get_char 2 = 'i').if {
        read_char;
        read_char;
        (base, exp) := (1024, 1);
      };
    }
    .when 'M' then {         read_char; (base, exp) := (10,    6);
      (next_char = 'i').if { read_char; (base, exp) := (1024,  2); }; }
    .when 'G' then {         read_char; (base, exp) := (10,    9);
      (next_char = 'i').if { read_char; (base, exp) := (1024,  3); }; }
    .when 'T' then {         read_char; (base, exp) := (10,   12);
      (next_char = 'i').if { read_char; (base, exp) := (1024,  4); }; }
    .when 'P' then {         read_char; (base, exp) := (10,   15);
      (next_char = 'i').if { read_char; (base, exp) := (1024,  5); }; }
    .when 'E' then {         read_char; (base, exp) := (10,   18);
      (next_char = 'i').if { read_char; (base, exp) := (1024,  6); }; }
    .when 'Z' then {         read_char; (base, exp) := (10,   21);
      (next_char = 'i').if { read_char; (base, exp) := (1024,  7); }; }
    .when 'Y' then {         read_char; (base, exp) := (10,   24);
      (next_char = 'i').if { read_char; (base, exp) := (1024,  8); }; };

    base, exp
  );
  
  //-- num_mult      -> num_ext_part
  //--                | num_unit
  - read_num_mult :(INTEGER, INTEGER) <-
  ( + base, exp :INTEGER;
    base := 10;

    ((exp := read_num_ext_part) = 0).if {
      (base, exp) := read_num_unit;
    };

    base, exp
  );
  
  //-- num_sign      -> [+-]
  - read_num_sign :CHARACTER <-
  ( + sign :CHARACTER;
    sign := '+';
    (((next_char = '+') || {next_char = '-'}) && {get_char 2.is_digit}).if {
      sign := read_char;
    };
    sign
  );
  
  //-- numeric       -> num_sign? num_base? integer ( '.' integer )? num_mult?
  - read_numeric :NUMBER <-
  ( + res :NUMBER;
    + sign :CHARACTER;
    + base, n :INTEGER;
    + num, dec, dec_shift :INTEGER;
    + mul, exp :INTEGER;

    sign := read_num_sign;
    next_char.is_digit.if {
      // Read base
      base := read_num_base;
      (base = 0).if { base := 10; };
      // Read entire part
      (num, n) := read_integer base;
      (sign = '-').if {
        num := -num;
      };
      res.set_numeric_part num;
      // Read decimal part
      ((next_char = '.') && {get_char 2.is_digit}).if {
        read_char;
        (dec, dec_shift) := read_integer base;
      };
      res.set_decimal dec shift dec_shift base base;
      // Read multiplier
      (mul, exp) := read_num_mult;
      res.set_exponent exp multiplier mul;
    };
    res
  );
  
  //-- int           -> [+-]?[0-9]+
  
  + last_int :INTEGER;
  
  - read_int :BOOLEAN <-
  ( + sign :INTEGER;
    + res  :BOOLEAN;
    
    sign := 1;
    ((last_character = '-') || {last_character = '+'}).if {
      (last_character = '-').if {
        sign := -1;
      };
      character 1.is_digit.if {
        read_character;
      };
    };
    last_character.is_digit.if {
      res := TRUE;
      last_int := 0;
      { last_character.is_digit }.while_do {
        last_int := 10*last_int + last_character.decimal_value;
        read_character;
      };
      last_int := last_int * sign;
    } else {
      res := FALSE;
    };
    res
  );
  
  //-- identifier -> [a-zA-Z_][a-zA-Z0-9_]*
  
  + last_identifier :STRING := STRING.create 64;
  
  - read_identifier :BOOLEAN <-
  ( + res:BOOLEAN;
    last_identifier.clear;
    last_character.is_digit.if_false {
      {(last_character.is_lower) ||
       {last_character.is_digit} ||
       {last_character = '_'}
      }.while_do {
        res := TRUE;
        last_identifier.add_last last_character;
        read_character;
      };
    };
    res
  );
  
  //-- keyword -> [A-Z][a-z0-9_]*
  
  + last_keyword :STRING := STRING.create 64;
  
  - read_keyword :BOOLEAN <-
  ( + res:BOOLEAN;
    last_keyword.clear;
    ((character 0.is_upper) && {character 1.is_lower}).if {
      res := TRUE;
      last_keyword.add_last last_character;
      read_character;
      {(last_character.is_lower) ||
       {last_character.is_digit} ||
       {last_character = '_'}
      }.while_do {
        last_keyword.add_last last_character;
        read_character;
      };
    };
    res
  );
  
  //-- cap_identifier -> [A-Z][A-Z0-9_]*
  
  + last_cap_identifier :STRING := STRING.create 64;
  
  - read_cap_identifier :BOOLEAN <-
  ( + res:BOOLEAN;
    last_cap_identifier.clear;
    (last_character.is_upper).if {
      res := TRUE;
      {(last_character.is_upper) ||
       {last_character.is_digit} ||
       {last_character = '_'}
      }.while_do {
        last_cap_identifier.add_last last_character;
        read_character;
      };
    };
    res
  );
  
  //-- string -> '"' string_content* '"'
  //-- string_content -> [^"] | '""'
  
  + last_string :STRING := STRING.create 128;
  
  - read_string :BOOLEAN <-
  ( + result :BOOLEAN;
    last_string.clear;
    (last_character = '"').if {
      read_character;
      read_string_content;
      read_always "\"";
      result := TRUE;
    };
    result
  );
  
  - read_string_content <-
  (
    ((character 0 = '"') && {character 1 = '"'}).if {
      last_string.add_last '"';
      read_character;
      read_character;
      read_string_content;
    }.elseif {last_character != '"'} then {
      last_string.add_last last_character;
      read_character;
      read_string_content;
    };
  );
  
  //-- symbol -> '`' symbol_content* '`'
  //-- symbol_content -> [^"] | '""'
  
  + last_symbol :STRING := STRING.create 128;
  
  - read_symbol :BOOLEAN <-
  ( + result :BOOLEAN;
    last_string.clear;
    (last_character = '`').if {
      read_character;
      read_symbol_content;
      read_always "`";
      result := TRUE;
    };
    result
  );
  
  - read_symbol_content <-
  (
    ((character 0 = '`') && {character 1 = '`'}).if {
      last_symbol.add_last '`';
      read_character;
      read_character;
      read_symbol_content;
    }.elseif {last_character != '`'} then {
      last_symbol.add_last last_character;
      read_character;
      read_symbol_content;
    };
  );
  
  //++ PROTOTYPE -> cap_identifier
  
  - read_prototype :ITM_EXPR_PROTO <-
  ( + res :ITM_EXPR_PROTO;
    + p :POS;
    p := position;
    read_cap_identifier.if {
      res := ITM_EXPR_PROTO.clone.make_position p.make last_cap_identifier;
    };
    res
  );
  
  //++ SECTION_HEADER -> . "Section" "Header" H_SLOTS
  
  - read_section_header <-
  (
    read_spaces;
    read_always "Section";
    read_spaces;
    read_always "Header";
    read_h_slots;
  );
  
  //++ H_SLOTS -> C_SLOT*
  
  - read_h_slots <-
  ( + slot :ITM_SLOT;
  
    ((slot := read_c_slot) != NULL).if {
      hook_header_slot slot;
      read_h_slots;
    };
  );
  
  - hook_header_slot slot:ITM_SLOT;
  
  //++ KEYWORDS -> keyword*
  
  - read_keywords :ITM_KEYWORDS <-
  ( + keywords:ITM_KEYWORDS;
    
    read_spaces;
    read_keyword.if {
      keywords := ITM_KEYWORDS.clone.make;
      keywords.add_keyword last_keyword;
      read_keywords_in keywords;
    };
    keywords
  );
  
  - read_keywords_in keywords:ITM_KEYWORDS :ITM_KEYWORDS <-
  (
    read_spaces;
    read_keyword.if {
      keywords.add_keyword last_keyword;
      read_keywords_in keywords;
    };
    keywords
  );
  
  //++ SECTIONS -> SECTION*
  
  - read_sections <-
  (
    read_section.if {
      read_sections;
    };
  );
  
  //++ SECTION -> "Section" . "Public" SECTION_CODE
  
  - read_section :BOOLEAN <-
  ( + res:BOOLEAN;
    + sec :ITM_SECTION;
  
    read_spaces;
    read_maybe "Section".if {
      sec := ITM_SECTION.clone.make;
      read_spaces;
      read_always "Public";
      read_spaces;
      res := TRUE;
      read_section_code sec;
    };
    res
  );
  
  //++ SECTION_CODE -> C_SLOTS
  
  - read_section_code sec:ITM_SECTION <-
  (
    read_c_slots sec;
  );

  //++ C_SLOTS -> C_SLOT*
  
  - read_c_slots sec:ITM_SECTION <-
  ( + slot :ITM_SLOT;
    ((slot := read_c_slot) != NULL).if {
      slot.set_section sec;
      handle_slot slot;
      read_c_slots sec;
    };
  );

  //++ C_SLOT -> style . identifier C_ARGS? (":" TYPE)? (affect keyword* EXPR)? ";"
  
  - read_c_slot :ITM_SLOT <-
  ( + slot :ITM_SLOT;
    + style :ITM_STYLE;
    + affect :ITM_AFFECT;
    + key :ITM_KEYWORDS;
    + type :ITM_TYPE;
    + p :POS;
    
    read_spaces;
    p := position;
    style := read_style;
    style.valid.if {
      slot := ITM_SLOT.clone.make_position p.make;
      slot.set_style style;
      read_spaces;
      read_identifier.if {
        slot.add_identifier last_identifier;
      };
      read_spaces;
      read_c_args slot;
      read_spaces;
      read_maybe ":" except ":=".if {
        read_spaces;
        type := read_type;
        (type = NULL).if {
          warning ("Expected type");
        } else {
          slot.set_return_type type;         
        };
        read_spaces;
      };
      affect := read_affect;
      affect.valid.if {
        ((key := read_keywords) != NULL).if {
          slot.set_keywords key;
        };
        slot.set_expression read_expr affect affect;
      };
      read_always ";";
    };
    slot
  );
  
  - handle_slot slot:ITM_SLOT;
  
  //++ C_ARGS -> "(" . (C_ARG ("," C_ARG)* )? ")"
  //++         | C_ARG
  
  - read_c_args slot:ITM_SLOT :BOOLEAN <-
  ( + res:BOOLEAN;
    read_spaces;
    read_maybe "(".if {
      read_spaces;
      (res := read_c_arg slot).if {
        {read_spaces; {res} && {read_maybe ","}}.while_do {
          read_spaces;
          res := read_c_arg slot;
        };
        res := TRUE;
      };
      read_spaces;
      read_always ")";
    } else {
      res := read_c_arg slot;
    };
    res
  );

  //++ C_ARG -> identifier . ":" TYPE
  
  - read_c_arg slot:ITM_SLOT :BOOLEAN <-
  ( + res :BOOLEAN;
    + idf :CSTRING;
    + type :ITM_TYPE;
  
    read_identifier.if {
      read_spaces;
      idf := last_identifier;
      read_always ":";
      type := read_type;
      (type = NULL).if {
        warning ("Expected type");
      } else {
        slot.add_argument (idf, type);
        res := TRUE;
      };
    };
    res
  );
  
  //++ TYPE -> PROTOTYPE
  //++       | '{' '}'
  
  - read_type :ITM_TYPE <-
  ( + proto :ITM_EXPR_PROTO;
    + res   :ITM_TYPE;
    + p     :POS;

    proto := read_prototype;
    (proto != NULL).if {
      res := ITM_TYPE.clone.make_position (proto.position).make proto;
    }.elseif {read_spaces; last_character = '{'} then {
      p := position;
      read_character;
      read_spaces;
      read_always "}";
      res := ITM_TYPE.clone.make_position p.make_block;
    } else {
      warning ("Expected type");
    };
    res
  );
  
  //++ EXPR -> symbol
  //++       | string
  //++       | int
  //++       | PROTOTYPE
  //++       | "(" GROUP ")"
  //++       | "{" GROUP "}"
  //++       | identifier (affect EXPR | EXPR_CALL)
  
  - read_expr :ITM_EXPR <-
  ( + res :ITM_EXPR;
    + tmp :ITM_EXPR;
    + proto :ITM_EXPR_PROTO;
    + pos :POS;
    res := ITM_EXPR_VOID;
    
    pos := position;
    read_symbol.if {
      res := ITM_EXPR_SYM.clone.make_position pos.make last_symbol;
    }.elseif {read_string} then {
      res := ITM_EXPR_STR.clone.make_position pos.make last_string;
    }.elseif {read_int} then {
      res := ITM_EXPR_INT.clone.make_position pos.make last_int;
    }.elseif {(proto := read_prototype) != NULL} then {
      res := proto;
    }.elseif {last_character = '('} then {
      pos := position;
      read_always "(";
      read_spaces;
      res := read_group pos;
      read_always ")";
    }.elseif {last_character = '{'} then {
      pos := position;
      read_always "{";
      read_spaces;
      res := read_group pos.set_block;
      read_always "}";
    }.elseif {read_identifier} then {
      + affect :ITM_AFFECT;
      + idf    :CSTRING;
      + p      :POS;
      idf    := last_identifier;
      read_spaces;
      p      := position;
      affect := read_affect;
      affect.valid.if {
        read_spaces;
        tmp := read_expr;
        tmp.is_void.if {
          warning "Affect of a VOID expression" in p;
        } else {
          res := ITM_EXPR_WRITE.clone.make_position pos.make_affect affect in idf of tmp;
        };
      } else {
        ((tmp := read_expr_call (idf, pos)) != NULL).if {
          res := tmp;
        };
      };
    };
    res
  );
  
  //++ EXPR_CALL -> EXPR? ("." . EXPR_CALL)?
  
  - read_expr_call (idf:CSTRING, pos:POS) :ITM_EXPR_READ <-
  ( + res :ITM_EXPR_READ;
    + self :ITM_EXPR;
    + expr :ITM_EXPR;
    + p1, p2 :POS;

    read_spaces;
    res := ITM_EXPR_READ.clone.make_position pos.make idf;
    expr := read_expr;
    expr.is_void.if_false {
      res.add_argument expr;
    };
    read_spaces;
    p1 := position;
    read_maybe ".".if {
      self := res;
      p2 := position;
      read_identifier.if {
        res := read_expr_call (last_identifier, p2);
        res.set_self self;
      } else {
        warning "Expected identifier after '.'" in p1;
      };
    };
    res
  );
  
  //++ GROUP -> (EXPR . ";")* (EXPR . ("," EXPR)*)?
  
  - read_group pos:POS :ITM_EXPR_GROUP <-
  ( + group :ITM_EXPR_GROUP;
    + expr  :ITM_EXPR;
    + p     :POS;
    
    group := ITM_EXPR_GROUP.clone.make_position pos.make;
    { read_spaces;
      p := position;
      expr := read_expr;
      expr.is_void.if_false {
        read_spaces;
        read_maybe ";".if {
          group.add_inst (ITM_INST_EXPR.clone.make_position p.make expr);
        } else {
          group.add_expr expr;
          {read_maybe ","}.while_do {
            read_spaces;
            expr := read_expr;
            expr.is_void.if_false {
              group.add_expr expr;
            };
            read_spaces;
          };
        };
      };
    }.do_until {expr.is_void};

    group
  );

  - open_source f:ABSTRACT_STRING <-
  ( + file:POINTER;
    + sz:INTEGER;

    filename := f;
    file := LIBC.fopen (f.to_external, "rb".to_external);
    sz := LIBC.file_size file;
    source := STRING.create (sz+1);
    LIBC.fread (source.storage, 1, sz, file);
    LIBC.fclose file;
    source.from_external (source.storage);
    position_index := source.lower;
    line := 1;
    column := 1;
  );

