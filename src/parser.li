Section Header

  + name      := PARSER;

Section Inherit

  + parent_any :Expanded ANY;

Section SELF

  + filename :CSTRING := "";
  + source :STRING;
  + position :INTEGER;
  + line :INTEGER;
  + column :INTEGER;
  
  - print_warning <-
  (
    STD_ERROR.put_string filename;
    STD_ERROR.put_string ":";
    STD_ERROR.put_integer line;
    STD_ERROR.put_string ":";
    STD_ERROR.put_integer column;
    STD_ERROR.put_string ": ";
  );
  
  - warning s:ABSTRACT_STRING <-
  (
    print_warning;
    STD_ERROR.put_string s;
    STD_ERROR.put_string "\n";
  );
  
  - character i:INTEGER :CHARACTER <-
  ( + c:CHARACTER;
    source.valid_index (position+i).if {
      c := source.item (position+i);
    } else {
      c := 0.to_character;
    };
    c
  );
  
  - last_character :CHARACTER <-
    character 0;
  
  - read_character :CHARACTER <-
  (
    source.valid_index position.if {
      position := position + 1;
      (character (-1) = '\n').if {
        line := line + 1;
        column := 1;
      } else {
        column := column + 1;
      };
    };
    last_character
  );
  
  - read_characters n:INTEGER <-
  (
    (n > 0).if {
      read_character;
      read_characters (n-1);
    };
  );
  
  - read_maybe str:ABSTRACT_STRING :BOOLEAN <-
  ( + i:INTEGER;
    + res :BOOLEAN;
    i := str.lower;
    {(i <= str.upper) && {character (i - str.lower) = str.item i}}.while_do {
      i := i + 1;
    };
    res := (i > str.upper);
    res.if {
      read_characters (str.count);
    };
    res
  );

  - read_always str:ABSTRACT_STRING <-
  (
    read_maybe str.if_false {
      warning ("expected \""+str+"\"");
    };
  );
  
  - read_spaces <-
  (
    {(last_character = 0.to_character) || {last_character > ' '}}.until_do {
      read_character;
    };
    ((last_character = '/') && {character 1 = '/'}).if {
      read_line_comment;
    }.elseif {(last_character = '/') && {character 1 = '*'}} then {
      read_nested_comment;
    };
  );
  
  - read_line_comment <-
  (
    ((last_character = '/') && {character 1 = '/'}).if {
      {(last_character = 0.to_character) || {last_character = '\n'} || {last_character = '\r'}}.until_do
      {
        read_character;
      };
    };
    read_spaces;
  );
  
  - read_nested_comment <-
  (
    ((last_character = '/') && {character 1 = '*'}).if {
      {(last_character = 0.to_character) || {(last_character = '*') && {character 1 = '/'}}}.until_do
      {
        read_character;
        ((last_character = '/') && {character 1 = '*'}).if {
          read_nested_comment;
        };
      };
    };
    read_spaces;
  );
  
  //-- style -> [+-]
  
  + last_style :ITM_STYLE;
  
  - read_style :ITM_STYLE <-
  (
    last_style := ITM_STYLE.clone.make last_character;
    last_style.valid.if {
      position := position + 1;
    };
    last_style
  );
  
  //-- affect -> ":=" | "?=" | "<-"
  
  + last_affect :ITM_AFFECT;
  
  - read_affect :ITM_AFFECT <-
  (
    read_maybe ":=".if {
      last_affect := ITM_AFFECT.clone.make ':';
    }.elseif {read_maybe "<-"} then {
      last_affect := ITM_AFFECT.clone.make '<';
    }.elseif {read_maybe "?="} then {
      last_affect := ITM_AFFECT.clone.make '?';
    } else {
      last_affect := ITM_AFFECT.clone.make (0.to_character);
    };
    last_affect
  );

  //-- integer       -> [0-9a-fA-F_]*
  - read_integer base:INTEGER :(INTEGER, INTEGER) <-
  ( + res :INTEGER;
    + val :INTEGER;
    + shift :INTEGER;

    { (next_char.is_digit)            ||
      {next_char.in_range 'a' to 'f'} ||
      {next_char.in_range 'A' to 'F'} ||
      {next_char = '_'}
    }.while_do {
      read_char;
      (last_char != '_').if {
        val := last_char.hexadecimal_value;
        (val >= base).if {
          warning ("Character '" + last_char.to_string + "' ignored: not allowed in base " + base.to_string);
        } else {
          res   := res * base + val;
          shift := shift + 1;
        };
      };
    };
    res, shift
  );

  //-- num_base      -> 0[xbod]
  //--                | 0([2-9a-fA-F]|1[0-6]):

  - read_num_base :INTEGER <-
  ( + base :INTEGER;
    + c1, c2, c3 :CHARACTER;
    (next_char = '0').if {
      c1 := get_char 2;
      c2 := get_char 3;
      c3 := get_char 4;
      ((c1 = '1') && {c2.in_range '0' to '6'} && {c3 = ':'}).if {
        ? {read_char = '0'};
        ? {read_char = '1'};
        ? {read_char.in_range '0' to '6'};
        base := 10 + last_char.decimal_value;
        ? {read_char = ':'};
        ? {base != 0};
      }.elseif {
        (c2 = ':') &&
        { (c1.in_range '2' to '9') ||
          {c1.in_range 'a' to 'f'} ||
          {c1.in_range 'A' to 'F'} }
      } then {
        ? {read_char = '0'};
        base := read_char.hexadecimal_value;
        ? {read_char = ':'};
        ? {base != 0};
      }.elseif {
        (c1 = 'x') || {c1 = 'b'} || {c1 = 'o'} || {c1 = 'd'}
      } then {
        ? {read_char = '0'};
        read_char
        .when 'b' then { base := 2;  }
        .when 'o' then { base := 8;  }
        .when 'd' then { base := 10; }
        .when 'x' then { base := 16; };
        ? {base != 0};
      };
    };
    base
  );

  //-- num_ext_part  -> [eE][+-]?[0-9][0-9_]*
  - read_num_ext_part :INTEGER <-
  ( + sign   :CHARACTER;
    + res, n :INTEGER;

    ((next_char = 'e') || {next_char = 'E'}).if {
      read_char;
      sign := read_num_sign;
      (res, n) := read_integer 10;
      (sign = '-').if {
        res := -res;
      };
    };

    res
  );
  
  //-- num_unit      -> ([yzafpnumkMGTPEZY]|[MGTPEZY]i)
  //--                  y  is  e-24
  //--                  ...
  //--                  f  is  e-15
  //--                  p  is  e-12
  //--                  n  is  e-9
  //--                  u  is  e-6
  //--                  m  is  e-3
  //--                  k  is  e3       Ki  is  1024
  //--                  M  is  e6       Mi  is  1024^2
  //--                  G  is  e9       Gi  is  1024^3
  //--                  T  is  e12      Ti  is  1024^4
  //--                  P  is  e15      Pi  is  1024^5
  //--                  ...
  //--                  Y  is  e24      Yi  is  1024^8
  //--                  Note: there is no K (with an uppercase K) suffix !!
  - read_num_unit :(INTEGER, INTEGER) <-
  ( + base, exp :INTEGER;
    base := 10;
    exp  := 0;

    next_char
    .when 'y' then { read_char; exp := -24; }
    .when 'z' then { read_char; exp := -21; }
    .when 'a' then { read_char; exp := -18; }
    .when 'f' then { read_char; exp := -15; }
    .when 'p' then { read_char; exp := -12; }
    .when 'n' then { read_char; exp :=  -9; }
    .when 'u' then { read_char; exp :=  -6; }
    .when 'm' then { read_char; exp :=  -3; }
    .when 'k' then { read_char; exp :=   3; }
    .when 'K' then {
      (get_char 2 = 'i').if {
        read_char;
        read_char;
        (base, exp) := (1024, 1);
      };
    }
    .when 'M' then {         read_char; (base, exp) := (10,    6);
      (next_char = 'i').if { read_char; (base, exp) := (1024,  2); }; }
    .when 'G' then {         read_char; (base, exp) := (10,    9);
      (next_char = 'i').if { read_char; (base, exp) := (1024,  3); }; }
    .when 'T' then {         read_char; (base, exp) := (10,   12);
      (next_char = 'i').if { read_char; (base, exp) := (1024,  4); }; }
    .when 'P' then {         read_char; (base, exp) := (10,   15);
      (next_char = 'i').if { read_char; (base, exp) := (1024,  5); }; }
    .when 'E' then {         read_char; (base, exp) := (10,   18);
      (next_char = 'i').if { read_char; (base, exp) := (1024,  6); }; }
    .when 'Z' then {         read_char; (base, exp) := (10,   21);
      (next_char = 'i').if { read_char; (base, exp) := (1024,  7); }; }
    .when 'Y' then {         read_char; (base, exp) := (10,   24);
      (next_char = 'i').if { read_char; (base, exp) := (1024,  8); }; };

    base, exp
  );
  
  //-- num_mult      -> num_ext_part
  //--                | num_unit
  - read_num_mult :(INTEGER, INTEGER) <-
  ( + base, exp :INTEGER;
    base := 10;

    ((exp := read_num_ext_part) = 0).if {
      (base, exp) := read_num_unit;
    };

    base, exp
  );
  
  //-- num_sign      -> [+-]
  - read_num_sign :CHARACTER <-
  ( + sign :CHARACTER;
    sign := '+';
    (((next_char = '+') || {next_char = '-'}) && {get_char 2.is_digit}).if {
      sign := read_char;
    };
    sign
  );
  
  //-- numeric       -> num_sign? num_base? integer ( '.' integer )? num_mult?
  - read_numeric :NUMBER <-
  ( + res :NUMBER;
    + sign :CHARACTER;
    + base, n :INTEGER;
    + num, dec, dec_shift :INTEGER;
    + mul, exp :INTEGER;

    sign := read_num_sign;
    next_char.is_digit.if {
      // Read base
      base := read_num_base;
      (base = 0).if { base := 10; };
      // Read entire part
      (num, n) := read_integer base;
      (sign = '-').if {
        num := -num;
      };
      res.set_numeric_part num;
      // Read decimal part
      ((next_char = '.') && {get_char 2.is_digit}).if {
        read_char;
        (dec, dec_shift) := read_integer base;
      };
      res.set_decimal dec shift dec_shift base base;
      // Read multiplier
      (mul, exp) := read_num_mult;
      res.set_exponent exp multiplier mul;
    };
    res
  );
  
  //-- int           -> [+-]?[0-9]+
  
  + last_int :INTEGER;
  
  - read_int :BOOLEAN <-
  ( + sign :INTEGER;
    + res  :BOOLEAN;
    
    sign := 1;
    ((last_character = '-') || {last_character = '+'}).if {
      (last_character = '-').if {
        sign := -1;
      };
      character 1.is_digit.if {
        read_character;
      };
    };
    last_character.is_digit.if {
      res := TRUE;
      last_int := 0;
      { last_character.is_digit }.while_do {
        last_int := 10*last_int + last_character.decimal_value;
        read_character;
      };
      last_int := last_int * sign;
    } else {
      res := FALSE;
    };
    res
  );
  
  //-- identifier -> [a-zA-Z_][a-zA-Z0-9_]*
  
  + last_identifier :STRING := STRING.create 64;
  
  - read_identifier :BOOLEAN <-
  ( + res:BOOLEAN;
    last_identifier.clear;
    last_character.is_digit.if_false {
      {(last_character.is_lower) ||
       {last_character.is_digit} ||
       {last_character = '_'}
      }.while_do {
        res := TRUE;
        last_identifier.add_last last_character;
        read_character;
      };
    };
    res
  );
  
  //-- keyword -> [A-Z][a-z0-9_]*
  
  + last_keyword :STRING := STRING.create 64;
  
  - read_keyword :BOOLEAN <-
  ( + res:BOOLEAN;
    last_keyword.clear;
    ((character 0.is_upper) && {character 1.is_lower}).if {
      res := TRUE;
      last_keyword.add_last last_character;
      read_character;
      {(last_character.is_lower) ||
       {last_character.is_digit} ||
       {last_character = '_'}
      }.while_do {
        last_keyword.add_last last_character;
        read_character;
      };
    };
    res
  );
  
  //-- cap_identifier -> [A-Z][A-Z0-9_]*
  
  + last_cap_identifier :STRING := STRING.create 64;
  
  - read_cap_identifier :BOOLEAN <-
  ( + res:BOOLEAN;
    last_cap_identifier.clear;
    (last_character.is_upper).if {
      res := TRUE;
      {(last_character.is_upper) ||
       {last_character.is_digit} ||
       {last_character = '_'}
      }.while_do {
        last_cap_identifier.add_last last_character;
        read_character;
      };
    };
    res
  );
  
  //-- string -> '"' string_content* '"'
  //-- string_content -> [^"] | '""'
  
  + last_string :STRING := STRING.create 128;
  
  - read_string :BOOLEAN <-
  ( + result :BOOLEAN;
    last_string.clear;
    (last_character = '"').if {
      read_character;
      read_string_content;
      read_always "\"";
      result := TRUE;
    };
    result
  );
  
  - read_string_content <-
  (
    ((character 0 = '"') && {character 1 = '"'}).if {
      last_string.add_last '"';
      read_character;
      read_character;
      read_string_content;
    }.elseif {last_character != '"'} then {
      last_string.add_last last_character;
      read_character;
      read_string_content;
    };
  );
  
  //-- symbol -> '`' symbol_content* '`'
  //-- symbol_content -> [^"] | '""'
  
  + last_symbol :STRING := STRING.create 128;
  
  - read_symbol :BOOLEAN <-
  ( + result :BOOLEAN;
    last_string.clear;
    (last_character = '`').if {
      read_character;
      read_symbol_content;
      read_always "`";
      result := TRUE;
    };
    result
  );
  
  - read_symbol_content <-
  (
    ((character 0 = '`') && {character 1 = '`'}).if {
      last_symbol.add_last '`';
      read_character;
      read_character;
      read_symbol_content;
    }.elseif {last_character != '`'} then {
      last_symbol.add_last last_character;
      read_character;
      read_symbol_content;
    };
  );
  
  //++ PROTOTYPE -> cap_identifier
  
  - read_prototype :ITM_EXPR_PROTO <-
  ( + res :ITM_EXPR_PROTO;
    read_cap_identifier.if {
      res := ITM_EXPR_PROTO.clone.make last_cap_identifier;
    };
    res
  );
  
  //++ SECTION_HEADER -> . "Section" "Header" H_SLOTS
  
  - read_section_header <-
  (
    read_spaces;
    read_always "Section";
    read_spaces;
    read_always "Header";
    read_h_slots;
  );
  
  //++ H_SLOTS -> C_SLOT*
  
  - read_h_slots <-
  ( + slot :ITM_SLOT;
  
    ((slot := read_c_slot) != NULL).if {
      hook_header_slot slot;
      read_h_slots;
    };
  );
  
  - hook_header_slot slot:ITM_SLOT;
  
  //++ KEYWORDS -> keyword*
  
  - read_keywords :ITM_KEYWORDS <-
  ( + keywords:ITM_KEYWORDS;
    
    read_spaces;
    read_keyword.if {
      keywords := ITM_KEYWORDS.clone.make;
      keywords.add_keyword last_keyword;
      read_keywords_in keywords;
    };
    keywords
  );
  
  - read_keywords_in keywords:ITM_KEYWORDS :ITM_KEYWORDS <-
  (
    read_spaces;
    read_keyword.if {
      keywords.add_keyword last_keyword;
      read_keywords_in keywords;
    };
    keywords
  );
  
  //++ SECTIONS -> SECTION*
  
  - read_sections <-
  (
    read_section.if {
      read_sections;
    };
  );
  
  //++ SECTION -> "Section" . "Public" SECTION_CODE
  
  - read_section :BOOLEAN <-
  ( + res:BOOLEAN;
    + sec :ITM_SECTION;
  
    read_spaces;
    read_maybe "Section".if {
      sec := ITM_SECTION.clone.make;
      read_spaces;
      read_always "Public";
      read_spaces;
      res := TRUE;
      read_section_code sec;
    };
    res
  );
  
  //++ SECTION_CODE -> C_SLOTS
  
  - read_section_code sec:ITM_SECTION <-
  (
    read_c_slots sec;
  );

  //++ C_SLOTS -> C_SLOT*
  
  - read_c_slots sec:ITM_SECTION <-
  ( + slot :ITM_SLOT;
    ((slot := read_c_slot) != NULL).if {
      slot.set_section sec;
      handle_slot slot;
      read_c_slots sec;
    };
  );

  //++ C_SLOT -> style . identifier C_ARG? (affect keyword* EXPR)? ";"
  
  - read_c_slot :ITM_SLOT <-
  ( + slot :ITM_SLOT;
    + style :ITM_STYLE;
    + affect :ITM_AFFECT;
    + key :ITM_KEYWORDS;
    
    read_spaces;
    style := read_style;
    style.valid.if {
      slot := ITM_SLOT.clone.make;
      slot.set_style style;
      read_spaces;
      read_identifier.if {
        slot.add_identifier last_identifier;
      };
      read_spaces;
      read_c_arg slot;
      read_spaces;
      affect := read_affect;
      affect.valid.if {
        ((key := read_keywords) != NULL).if {
          slot.set_keywords key;
        };
        slot.set_expression read_expr;
      };
      read_always ";";
    };
    slot
  );
  
  - handle_slot slot:ITM_SLOT;
  
  //++ C_ARG -> identifier . ":" TYPE
  
  - read_c_arg slot:ITM_SLOT :BOOLEAN <-
  ( + res :BOOLEAN;
    + idf :CSTRING;
    + type :ITM_TYPE;
  
    read_identifier.if {
      read_spaces;
      idf := last_identifier;
      read_always ":";
      type := read_type;
      (type = NULL).if {
        warning ("Expected type");
      } else {
        slot.add_argument (idf, type);
      };
    };
    res
  );
  
  //++ TYPE -> PROTOTYPE
  //++       | '{' '}'
  
  - read_type :ITM_TYPE <-
  ( + proto :ITM_EXPR_PROTO;
    + res   :ITM_TYPE;

    proto := read_prototype;
    (proto != NULL).if {
      res := ITM_TYPE.clone.make proto;
    }.elseif {read_spaces; last_character = '{'} then {
      read_character;
      read_spaces;
      read_always "}";
      res := ITM_TYPE.clone.make_block;
    } else {
      warning ("Expected type");
    };
    res
  );
  
  //++ EXPR -> symbol
  //++       | string
  //++       | int
  //++       | PROTOTYPE
  //++       | "(" GROUP ")"
  //++       | "{" GROUP "}"
  //++       | EXPR_CALL
  
  - read_expr :ITM_EXPR <-
  ( + res :ITM_EXPR;
    + tmp :ITM_EXPR;
    + proto :ITM_EXPR_PROTO;
    res := ITM_EXPR_VOID;
    
    read_symbol.if {
      res := ITM_EXPR_SYM.clone.make last_symbol;
    }.elseif {read_string} then {
      res := ITM_EXPR_STR.clone.make last_string;
    }.elseif {read_int} then {
      res := ITM_EXPR_INT.clone.make last_int;
    }.elseif {(proto := read_prototype) != NULL} then {
      res := proto;
    }.elseif {last_character = '('} then {
      read_always "(";
      read_spaces;
      res := read_group;
      read_always ")";
    }.elseif {last_character = '{'} then {
      read_always "{";
      read_spaces;
      res := read_group.set_block;
      read_always "}";
    }.elseif {(tmp := read_expr_call) != NULL} then {
      res := tmp;
    };
    res
  );
  
  //++ EXPR_CALL -> identifier . EXPR? ("." . EXPR_CALL)?
  
  - read_expr_call :ITM_EXPR_READ <-
  ( + res :ITM_EXPR_READ;
  
    (read_identifier).if {
      + self :ITM_EXPR;
      + expr :ITM_EXPR;
      + idf :CSTRING;
      idf := last_identifier;
      read_spaces;
      expr := read_expr;
      res := ITM_EXPR_READ.clone.make (idf, expr);
      read_spaces;
      (last_character = '.').if {
        read_always ".";
        self := res;
        res := read_expr_call;
        res.set_self self;
      };
    };
    res
  );
  
  //++ GROUP -> INSTS
  
  - read_group :ITM_EXPR_GROUP <-
  ( + res :ITM_EXPR_GROUP;
    res := ITM_EXPR_GROUP.clone.make;
    read_insts res;
    res
  );
  
  //++ INSTS -> INST*
  
  - read_insts group:ITM_EXPR_GROUP <-
  ( + inst :ITM_INST;
    ((inst := read_inst) != NULL).if {
      group.add_inst inst;
      read_insts group;
    };
  );
  
  //++ INST -> EXPR ";"
  
  - read_inst :ITM_INST <-
  ( + expr :ITM_EXPR;
    + res :ITM_INST;
  
    read_spaces;
    expr := read_expr;
    expr.is_void.if_false {
      read_spaces;
      read_always ";";
      res := ITM_INST_EXPR.clone.make expr;
    };
    res
  );
  
  - open_source f:ABSTRACT_STRING <-
  ( + file:POINTER;
    + sz:INTEGER;

    filename := f;
    file := LIBC.fopen (f.to_external, "rb".to_external);
    sz := LIBC.file_size file;
    source := STRING.create (sz+1);
    LIBC.fread (source.storage, 1, sz, file);
    LIBC.fclose file;
    source.from_external (source.storage);
    position := source.lower;
    line := 1;
    column := 1;
  );

