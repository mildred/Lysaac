Section Header

  + name := EXPR;
  
  - export := REG, TYPE;

Section Inherit

  + parent_any :Expanded ANY;

Section Public
  
  - make_duplicate_of other:SELF <-
  (
    reg := other.reg.dup;
  );

  + reg  :REG  := REG;
  + type :TYPE := NULL;
  
  - is_valid :BOOLEAN <- (((reg != NULL) || {reg.is_valid}) && {type != NULL});
  
  - make_type t:TYPE value r:REG :SELF <- make(r, t);

  - make (r:REG, t:TYPE) :SELF <-
  [
    -? { t != NULL };
    -? { r != NULL };
    -? { ! r.base_type.void };
    -? { r.is_valid };
    t.is_impl.if {
      (t.ref_base_type == r.base_type).if_false {
        warnln(t.ref_base_type.to_string + " (type) != " + r.base_type.to_string + " (reg)");
      };
      -? { t.ref_base_type == r.base_type };
    };
  ]
  (
    reg  := r;
    type := t;
    Self
  )
  [
    +? { is_valid };
  ];
  
  - make_type t:TYPE :SELF <-
  [
    -? { t != NULL };
    -? { t.can_create_reg };
  ]
  (
    make(t.create_reg, t)
  );

  - to_reg  :REG  <- [ -? { reg != NULL }; ] reg;
  - to_type :TYPE <- [ -? { is_valid    }; ] type;
  
  - to_string :STRING <- ( type_name + "<" + reg.to_string + ";" + type.to_string + ">" );
  
  - implement_type_with other:TYPE_IMPL :ERR <-
  ( + res:ERR;
    type.to_impl_of other.if { t:TYPE_IMPL;
      type := t;
      reg.resolve_base_type_with (t.ref_base_type);
    } else_error { e:ERR;
      res  := e;
    };
    res
  );

