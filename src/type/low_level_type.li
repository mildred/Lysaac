Section Header

  + name := LOW_LEVEL_TYPE;

Section Inherit

  + parent_base_type :Expanded BASE_TYPE;

Section Public
  
  - make_duplicate_of other:SELF <-
  (
    kind
    .when kind_pointer then {
      p_type := other.pointer_type.dup;
    }
    .when kind_struct then {
      make_struct;
      struct_types.iterate.loop_v { t:LOW_LEVEL_TYPE;
        struct_types.add_last (t.dup);
      };
    }
    .when kind_vector then {
      p_type := other.vector_type.dup;
    };
  );

  //
  // Kind of type
  //

  - kind_void     :INTEGER := 0;
  - kind_integer  :INTEGER := 1;
  - kind_pointer  :INTEGER := 2;
  - kind_function :INTEGER := 3;
  - kind_struct   :INTEGER := 4;
  - kind_vector   :INTEGER := 5;
  
  - kind :INTEGER <-
  ( + kind :INTEGER;
  
    (i_size != 0).if {
      kind := kind_integer;
    }.elseif {m_vector_size >= 0} then {
      kind := kind_vector;
    }.elseif {p_type != NULL} then {
      kind := kind_pointer;
    }.elseif {f_ptr} then {
      kind := kind_function;
    }.elseif {m_struct != NULL} then {
      kind := kind_struct;
    } else {
      kind := kind_void;
    };
    
    kind
  );
  
  //
  // Type: void
  //
  
  - is_void :BOOLEAN <- (kind == kind_void);
  - void :BOOLEAN <- (kind == kind_void);
  
  - void_type :SELF := clone.make_void;
  
  //
  // Type: integer
  //
  
  - create_integer size:INTEGER  :SELF <- clone.make_integer size;
  
  - create_integer_cst           :SELF <- clone.make_integer (-1);

  - integer      :BOOLEAN <- (kind == kind_integer);
  - integer_size :INTEGER <- [ -?{integer}; ] i_size;
  - integer_cst  :BOOLEAN <- [ -?{integer}; ] (i_size < 0);
  
  - i1  :LOW_LEVEL_TYPE := create_integer 1;
  - i8  :LOW_LEVEL_TYPE := create_integer 8;
  - i16 :LOW_LEVEL_TYPE := create_integer 16;
  - i32 :LOW_LEVEL_TYPE := create_integer 32;
  - i64 :LOW_LEVEL_TYPE := create_integer 64;
  - int :LOW_LEVEL_TYPE <- create_integer_cst;
  // int is created each time because when the type is resolved, it changes
  
  //
  // Type: pointer
  //
  
  - create_pointer ptr:LOW_LEVEL_TYPE :SELF <- clone.make_pointer ptr;
  
  - is_pointer       :BOOLEAN <- (kind == kind_pointer);
  - dereference_type :ABSTRACT_TYPE <- pointer_type;

  - pointer      :BOOLEAN <- (kind == kind_pointer);
  - pointer_type :LOW_LEVEL_TYPE <- [ -?{pointer}; ] p_type;
  
  //
  // Type: function
  //
  
  - create_function :SELF <- clone.make_function;
  
  - function :BOOLEAN <- (kind == kind_function);
  
  //
  // Type: struct
  //
  
  - create_struct :SELF <- clone.make_struct;
  
  - struct       :BOOLEAN <- (kind == kind_struct);
  - struct_types :FAST_ARRAY(LOW_LEVEL_TYPE) <- [ -? {struct}; ] m_struct;
  
  //
  // Type: vector
  //
  
  - create_vector items:INTEGER of t:LOW_LEVEL_TYPE :SELF <- clone.make_vector items of t;
  
  - vector        :BOOLEAN <- (kind == kind_vector);
  - vector_length :INTEGER   <- [ -?{vector}; ] m_vector_size;
  - vector_type   :LOW_LEVEL_TYPE <- [ -?{vector}; ] p_type;
  
  //
  // Generic
  //
  
  - compatible_with other:LOW_LEVEL_TYPE :BOOLEAN <- compatible_with other and_resolve FALSE;
  - resolve_with other:LOW_LEVEL_TYPE :BOOLEAN <- compatible_with other and_resolve TRUE;
  
  - compatible_with other:LOW_LEVEL_TYPE and_resolve do_resolve:BOOLEAN :BOOLEAN <-
  ( + res:BOOLEAN;
    (kind == other.kind).if {
      
      kind
      .when kind_void then {
        res := TRUE;
      }
      .when kind_integer then {
        (do_resolve && {integer_cst}).if {
          i_size := other.integer_size;
          ? {integer_size == other.integer_size};
        };
        res := (integer_size == other.integer_size) ||
               {(!do_resolve) && {integer_cst}};
      }
      .when kind_pointer then {
        res := pointer_type.compatible_with (other.pointer_type) and_resolve do_resolve;
      }
      .when kind_function then {
        res := TRUE;
      }
      .when kind_struct then {
        res := (struct_types.count = other.struct_types.count);
        res.if {
          (struct_types.lower).to(struct_types.upper) do { i:INTEGER;
            res := res && {
              struct_types.item i
                .compatible_with (other.struct_types.item i)
                     and_resolve do_resolve
            };
          };
        };
      }
      .when kind_vector then {
        res := (vector_length == other.vector_length) &&
               {vector_type.compatible_with (other.vector_type) and_resolve do_resolve};
      };
    };
    res
  );
  
  - generate gen:GENERATOR <-
  [ -? { Self != SELF }; ]
  (
    kind
    .when kind_void then {
      gen.type_void;
    }
    .when kind_integer then {
      gen.type_integer integer_size;
    }
    .when kind_pointer then {
      gen.type_pointer {
        pointer_type.generate gen;
      };
    }
    .when kind_function then {
      gen.type_function;
    }
    .when kind_struct then {
      gen.type_struct {
        struct_types.iterate.loop_v { t:LOW_LEVEL_TYPE;
          gen.type_struct_element { t.generate gen }
        };
      };
    }
    .when kind_vector then {
      gen.type_vector m_vector_size of {
        p_type.generate gen;
      };
    };
  );
  
  - realize_default_value gen:GENERATOR for reg:REG <-
  (
    gen.expr_undef_in reg
  );
  
  - equals_to other:SELF :BOOLEAN <-
  (
    (other != NULL) && {kind = other.kind} &&
    { + res:BOOLEAN;
    
      kind
      .when kind_void then {
        res := TRUE;
      }
      .when kind_integer then {
        res := (integer_size == other.integer_size);
      }
      .when kind_pointer then {
        res := (pointer_type == other.pointer_type);
      }
      .when kind_function then {
        res := TRUE;
      }
      .when kind_struct then {
        res := (struct_types == other.struct_types);
      }
      .when kind_vector then {
        res := (vector_length == other.vector_length) &&
               {vector_type   == other.vector_type};
      };
      
      res
    }
  );
  
  - to_llvm_in res:STRING :STRING <-
  (
    kind
    .when kind_void then {
      res.append "void";
    }
    .when kind_integer then {
      integer_cst.if {
        res.append "int";
      } else {
        res.append "i";
        integer_size.append_in res;
      };
    }
    .when kind_pointer then {
      pointer_type.to_llvm_in res;
      res.append "*";
    }
    .when kind_function then {
      res.append "void()";
    }
    .when kind_struct then {
      res.append "{";
      m_struct.iterate.loop_v { t:LOW_LEVEL_TYPE;
        t.to_llvm_in res;
        res.add_last ',';
      };
      (m_struct.count > 0).if {
        res.remove_last 1;
      };
      res.append "}";
    }
    .when kind_vector then {
      res.append "[";
      vector_length.append_in res;
      res.append "x";
      vector_type.to_llvm_in res;
      res.append "]";
    };
    res
  );

  - to_string:STRING <-
  ( + res :STRING;
    res := type_name + "<";
    to_llvm_in res;
    res.append ">";
    res
  );

Section Private

  + i_size        :INTEGER               := 0;
  + p_type        :LOW_LEVEL_TYPE             := NULL;
  + f_ptr         :BOOLEAN               := FALSE;
  + m_vector_size :INTEGER               := -1;
  + m_struct      :FAST_ARRAY(LOW_LEVEL_TYPE) := NULL;
  
  - make_void size:INTEGER :SELF <-
  (
    i_size := 0;
    p_type := NULL;
    f_ptr  := FALSE;
    m_vector_size := -1;
    m_struct := NULL;
    ? { kind == kind_void };
    Self
  );
  
  - make_integer size:INTEGER :SELF <-
  (
    i_size := size;
    p_type := NULL;
    f_ptr  := FALSE;
    m_vector_size := -1;
    m_struct := NULL;
    ? { kind == kind_integer };
    Self
  );
  
  - make_pointer ptr:LOW_LEVEL_TYPE :SELF <-
  (
    i_size := 0;
    p_type := ptr;
    f_ptr  := FALSE;
    m_vector_size := -1;
    m_struct := NULL;
    ? { kind == kind_pointer };
    Self
  );
  
  - make_function :SELF <-
  (
    i_size := 0;
    p_type := NULL;
    f_ptr  := TRUE;
    m_vector_size := -1;
    m_struct := NULL;
    ? { kind == kind_function };
    Self
  );
  
  - make_struct :SELF <-
  (
    i_size := 0;
    p_type := NULL;
    f_ptr  := FALSE;
    m_vector_size := -1;
    m_struct := FAST_ARRAY(LOW_LEVEL_TYPE).create 0;
    ? { kind == kind_struct };
    Self
  );
  
  - make_vector items:INTEGER of t:LOW_LEVEL_TYPE :SELF <-
  (
    i_size := 0;
    p_type := t;
    f_ptr  := FALSE;
    m_vector_size := items;
    m_struct := NULL;
    ? { kind == kind_vector };
    Self
  );
