Section Header

  + name := REG;
  
  // A var is a promise between a SINGLE producer (writer) and a consumer
  // (reader). It is realized when the generator gives it a name or an
  // identifier. It corresponds to an LLVM register.

Section Inherit

  + parent_any :Expanded ANY;
  
Section Public

  - to_string :STRING <-
  ( + res:STRING;
    res := type_name + "<" + name + "," + identifier.to_string + "," + pretty_name + ",";
    (type = NULL).if {
      res.append "NULL>";
    } else {
      res.append (type.to_string + ">");
    };
    res
  );
  
  //
  // Predicates
  //

  - is_realized :BOOLEAN <- ( name.count != 0 );
  
  - is_valid :BOOLEAN <- ( type != NULL );
  - is_null  :BOOLEAN <- ( ! is_valid );
  
  - has_writer :BOOLEAN <- (writer_instruction != NULL);
  
  //
  // Attributes
  //
  
  - writer :INSTR <-
  [ -? {has_writer}; ]
  ( writer_instruction );
  
  + type :TYPE := NULL;
  
  + pretty_name :CSTRING := "";
  
  //
  // Construction
  //

  - make writer_instr:INSTR static_type t:TYPE :SELF <-
  [ -? { t != NULL }; ]
  (
    writer_instruction := writer_instr;
    type := t;
    name := "";
    identifier := 0;
    pretty_name := "";
    Self
  );
  
  - make_pretty_name n:CSTRING :SELF <-
  (
    pretty_name := n;
    Self
  );
  
  //
  // Realization
  //
  
  - realize_using v:REG <-
  (
    realize (v.name) id (v.identifier);
  );
  
  //
  // Generation
  //

  - generate_arg gen:GENERATOR <- generate_arg gen name pretty_name;
  
  - generate_arg gen:GENERATOR name n:CSTRING <-
  [ -? { is_valid }; ]
  (
    type.base_type.void.if_false {
      gen.arg_name n variable Self type { type.generate gen; };
    };
  );

Section GENERATOR

  + identifier :INTEGER := 0;
  + name :CSTRING := "";
  
  - base_type :BASE_TYPE;

  - realize n:CSTRING :SELF <-
  [ -? { SELF != Self };
    -? { name.count = 0 };
    -? { identifier = 0 };
  ]
  (
    name := n;
    identifier := 0;
    Self
  );

  - realize n:CSTRING id id:INTEGER :SELF <-
  [ -? { SELF != Self }; ]
  (
    name := n;
    identifier := id;
    Self
  );

Section Private

  + writer_instruction :INSTR;
