Section Header

  + name := ITM_EXPR_GROUP;

Section Inherit

  + parent_itm_expr :Expanded ITM_EXPR;

Section Public

  - is_void :BOOLEAN <- FALSE;

  + is_block :BOOLEAN;
  
  - has_results :BOOLEAN <- TRUE;

  + result  :EXPR := EXPR;
  
  + results :FAST_ARRAY(EXPR);
  
  + has_multiple_results :BOOLEAN := FALSE;

  - compile_in list:LIST :SELF <-
  (
    ? { err.success };
    is_block.if {
      cluster_parent.type_block.if { t:TYPE;
        + block :PROC_BLOCK;
        block := PROC_BLOCK.clone.make_block Self list_parent list;
        result := EXPR.clone.make
        (
          INSTR_FNPTR
            .clone
            .make (block.external_name) type_block t
            .add_in list
            .result,
          t
        );
        list.list_procs.add_block block;
        is_block := FALSE;
      } else {
        err := error (err, position, "Could not find role for Block");
      };
    } else {
      locals.iterate.loop_v { l:ITM_LOCAL;
        l.compile_storage_in list;
      };
      instructions.iterate.loop_v { i:ITM_INST;
        i.compile_in list;
      };
      has_multiple_results := TRUE;
      result_exprs.iterate.loop_v { e:ITM_EXPR;
        ? { + l:ITM_LOCAL; l ?= e; l = NULL };
        e.compile_in list;
        e.err.failure.if {
          list.error_collector.add_error (e.err);
        } else {
          results.add_last (e.result);
        };
      };
    };
    Self
  );
    
  + err :ERR;

  - to_string :STRING <-
  ( + res :STRING;
    res := type_name.to_string;
    is_block.if {
      res.add_last '{';
    } else {
      res.add_last '(';
    };
    res.add_last ' ';
    instructions.iterate.loop_v { i :ITM_INST;
      res.append (i.to_abstract_string);
      res.append "; ";
    };
    is_block.if {
      res.add_last '}';
    } else {
      res.add_last ')';
    };
    res
  );

Section ITM

  - lookup_local name:CSTRING :ITM_LOCAL <-
  ( + it :ITERATOR(ITM_LOCAL);
    + res :ITM_LOCAL;
    
    (it := locals.iterate).loop_v { l:ITM_LOCAL;
      (l.name = name).if {
        it.stop;
        res := l;
      };
    };
    (res = NULL).if {
      res := itm_parent.lookup_local name;
    };
    res
  );

Section PARSER

  - make :SELF <-
  (
    err          := ERR;
    is_block     := FALSE;
    instructions := FAST_ARRAY(ITM_INST).create 0;
    result_exprs := FAST_ARRAY(ITM_EXPR).create 0;
    results      := FAST_ARRAY(EXPR).create (result_exprs.count);
    locals       := FAST_ARRAY(ITM_LOCAL).create 0;
    ? { err.success };
    Self
  );
  
  - set_block :SELF <-
  [ -?{ ! is_block }; ]
  (
    is_block := TRUE;
    Self
  );
  
  - add_inst inst:ITM_INST <-
  (
    inst.set_itm_parent Self;
    instructions.add_last inst;
  );
  
  - add_expr expr:ITM_EXPR <-
  [
    -? { + l:ITM_LOCAL; l ?= expr; l = NULL };
  ]
  (
    expr.set_itm_parent Self;
    result_exprs.add_last expr;
  );
  
  - add_local local:ITM_LOCAL <-
  (
    local.set_itm_parent Self;
    locals.add_last local;
  );

Section Private

  + locals :FAST_ARRAY(ITM_LOCAL);

  + instructions :FAST_ARRAY(ITM_INST);

  + result_exprs :FAST_ARRAY(ITM_EXPR);
  
