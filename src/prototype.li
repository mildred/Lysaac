Section Header

  + name := PROTOTYPE;

Section Inherit

  + parent_any :Expanded ANY;
  
  - parent_type_finder :Expanded TYPE_FINDER;
  
  + parent_error_collector :Expanded ERR_COLLECTOR;

Section Public

  - made      :BOOLEAN <- state >= state_made;      // Object is made and ready
  - parsed    :BOOLEAN <- state >= state_parsed;    // AST is parsed
  - defined   :BOOLEAN <- state >= state_defined;   // External interfaces are defined
  - compiled  :BOOLEAN <- state >= state_compiled;  // Internal code is compiled
  - generated :BOOLEAN <- state >= state_generated; // Code is generated.

  - find_type type_name:CSTRING :TYPE <-
  [
    -? { made };
    -? { cluster.parsed };
  ]
  (
    cluster.find_type type_name
  );
  
  + base_type :BASE_TYPE <-
  // The Expanded LLVM type
  [ -? {defined}; ]
  (
    (role == "Block").if {
      base_type := BASE_TYPE.create_function;
    } else {
      base_type := BASE_TYPE.create_struct;
      slots.iterate.loop_v { s:SLOT;
        s.is_compiled_data_slot.if {
          base_type.struct_types.add_last (s.result_type.base_type);
        };
      };
    };
    base_type
  );
  
  - void :BOOLEAN <- base_type.void;
  
  + filename :CSTRING;
  
  + role :CSTRING := "";
  
  + cluster :CLUSTER;
  
  + expanded :BOOLEAN;
  
  + name :CSTRING <-
  ( + str :ABSTRACT_STRING;
    
    str := PATH_HELPER.basename filename;
    name := str.substring (str.lower) to (str.upper - 3).as_upper
  );
  
  + position :POS;
  
  - parse <-
  [ -? {made}; -? {! parsed}; ]
  ( + e :ERR;
    (ast, e) := parser.parse;
    e.failure.if { add_error e; };
    state := state_parsed;
  )
  [ +? {parsed}; ];
  
  - define_in list:LIST_PROC <-
  [ -? {parsed}; -?{!defined}; ]
  (
    ast.define_in list;
    state := state_defined;
  )
  [ +? { defined }; ];
  
  - compile <-
  [ -? {defined}; -? {! compiled}; ]
  (
    prototype_value  := REG.clone.make_type (BASE_TYPE.create_pointer base_type);
    initializer_list := LIST
      .clone
      .make_error_collector Self type NULL;
    initializer_list.make_self (compile_prototype_value_in initializer_list);
    state := state_compiled;
  )
  [ +? {compiled}; ];
  
  - link <-
  (
    initializer_list.link;
    state := state_linked;
  );
  
  - generate gen:GENERATOR <-
  [ -? {compiled}; -? {! generated}; ]
  (
    generate_prototype_value gen;
    generate_initializer gen;
    state := state_generated;
  )
  [ +? {generated}; ];

  - to_string :STRING <- type_name + "<" + name + ">";
  
  - compile_prototype_value_in l:LIST :EXPR <-
  [ -? { l != NULL }; ]
  ( + res:REG;
    
    expanded.if {
      res := INSTR_LOAD
        .clone
        .make prototype_value
        .add_in l
        .result;
    } else {
      res := prototype_value;
    };
    
    EXPR.clone.make (res, to_type)
  );

Section Private

  - generate_initializer gen:GENERATOR <-
  (
    gen.ctor_sub 65535 do {
      ? { prototype_value.is_realized };
      initializer_list.generate gen;
    };
  );

  - generate_prototype_value gen:GENERATOR <-
  [ -? { ! prototype_value.is_realized }; ]
  (
    (role == "Block").if {
      gen.global_block_prototype_value prototype_value name name;
    } else {
      gen.global_prototype_value prototype_value name name;
    };
  )
  [ +? { prototype_value.is_realized }; ];

Section ITM_EXPR

  - find_slot name:CSTRING :SLOT <-
  [ -? {parsed}; ]
  ( + it:ITERATOR(SLOT);
    + res :SLOT;
    
    (it := slots.iterate).loop_v { s:SLOT;
      (s.name = name).if {
        res := s;
        it.stop;
      };
    };
    res
  );

Section CLUSTER, ITM_TYPE, SLOT, INSTR_FNPTR

  - to_type :TYPE <-
  [ -? {made}; ]
  (
    (role == "Block").if {
      type := to_type_block;
    }.elseif {type = NULL} then {
      type := TYPE.clone.make Self;
    };
    type
  );

  - to_type_block :TYPE <-
  [ -? {made}; ]
  (
    (type_block = NULL).if {
      type_block := TYPE.clone.make_block Self;
    };
    type_block
  );

Section CLUSTER_ITEM

  - make_file file:CSTRING cluster c:CLUSTER :SELF <-
  (
    make_error_collector file;
    expanded := FALSE;
    cluster  := c;
    filename := file;
    ast      := NULL;
    slots    := FAST_ARRAY(SLOT).create 0;
    parser   := PARSER_LI.clone.make Self;
    position := POS.create(file, 0, 0);
    state    := state_made;
    initializer_list := NULL;
    prototype_value := REG;
    type       := NULL;
    type_block := NULL;
    num_compiled_data_slots := 0;
    Self
  );

Section PARSER_LI

  - set_role r:CSTRING <-
  [ -? {made}; -? {! parsed}; ]
  (
    role := r;
    cluster.set_prototype Self for_role r;
  );

  - set_base_type t:BASE_TYPE <-
  [
    -? {made};
    -? {! parsed};
    -? { t != NULL };
  ]
  (
    base_type := t;
  );
  
  - make_expanded :SELF <-
  (
    expanded := TRUE;
    Self
  );

Section SLOT

  + initializer_list :LIST; // TODO: generate

  - add_slot s:SLOT <-
  (
    add_error_collector_child s;
    slots.add_last s;
    ((s.style.plus) && {s.has_result}).if {
      s.set_type_index num_compiled_data_slots;
      num_compiled_data_slots := num_compiled_data_slots + 1;
    };
  );

Section SLOT_BLOCK

  - add_slot_block s:SLOT_BLOCK <-
  (
    add_error_collector_child s;
    slots.add_last s;
  );

Section Private

  + num_compiled_data_slots :INTEGER := 0;

  + state :INTEGER;
  
  - state_none      :INTEGER := 0;
  - state_made      :INTEGER := 1;
  - state_parsed    :INTEGER := 3;
  - state_defined   :INTEGER := 4;
  - state_compiled  :INTEGER := 5;
  - state_linked    :INTEGER := 6;
  - state_generated :INTEGER := 7;

  + parser :PARSER_LI;

  + ast :ITM_PROTOTYPE;

  + slots :FAST_ARRAY(SLOT);
  
  + type :TYPE;
  
  + type_block :TYPE;
  
  + prototype_value :REG;


