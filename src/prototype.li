Section Header

  + name := PROTOTYPE;

Section Inherit

  + parent_any :Expanded ANY;
  
  - parent_i_find_type :Expanded I_FIND_TYPE;

Section Public

  - made      :BOOLEAN <- state >= state_made;      // Object is made and ready
  - parsed    :BOOLEAN <- state >= state_parsed;    // AST is parsed
  - defined   :BOOLEAN <- state >= state_defined;   // External interfaces are defined
  - compiled  :BOOLEAN <- state >= state_compiled;  // Internal code is compiled
  - generated :BOOLEAN <- state >= state_generated; // Code is generated.

  - find_type type_name:CSTRING :TYPE <- cluster.find_type type_name;
  
  + base_type :BASE_TYPE <-
  [ -? {defined}; ]
  (
    base_type := BASE_TYPE.create_struct;
    slots.iterate.loop_v { s:SLOT;
      s.is_compiled_data_slot.if {
        base_type.struct_types.add_last (s.result_type.base_type);
      };
    };
    base_type
  );
  
  + prototype_value :EXPR;
  
  - void :BOOLEAN <- base_type.void;
  
  + filename :CSTRING;
  
  + role :CSTRING := "";
  
  + cluster :CLUSTER;
  
  + expanded :BOOLEAN;
  
  + name :CSTRING <-
  ( + str :ABSTRACT_STRING;
    
    str := PATH_HELPER.basename filename;
    name := str.substring (str.lower) to (str.upper - 3).as_upper
  );
  
  - parse <-
  [ -? {made}; -? {! parsed}; ]
  ( + e :ERR;
    (ast, e) := parser.parse;
    e.assert;
    state := state_parsed;
  )
  [ +? {parsed}; ];
  
  - define_in list:LIST_PROC <-
  [ -? {parsed}; -?{!defined}; ]
  (
    ast.define_in list;
    state := state_defined;
  )
  [ +? { defined }; ];
  
  - compile <-
  [ -? {defined}; -? {! compiled}; ]
  (
    prototype_value  := EXPR.clone.make_type to_type;
    warnln ("prototype_value type " + prototype_value.reg.base_type.to_string);
    initializer_list := LIST.clone.make_self prototype_value;
    state := state_compiled;
  )
  [ +? {compiled}; ];
  
  - link <-
  (
    initializer_list.link;
    state := state_linked;
  );
  
  - generate gen:GENERATOR <-
  [ -? {compiled}; -? {! generated}; ]
  (
    generate_prototype_value gen;
    generate_initializer gen;
    state := state_generated;
  )
  [ +? {generated}; ];
  
  - to_string :STRING <- type_name + "<" + name + ">";

Section Private

  - generate_initializer gen:GENERATOR <-
  (
    gen.ctor_sub 65535 do {
      ? { prototype_value.reg.is_realized };
      initializer_list.generate gen;
    };
  );

  - generate_prototype_value gen:GENERATOR <-
  [ -? { ! prototype_value.reg.is_realized }; ]
  (
    gen.global_prototype_value prototype_value name name;
  )
  [ +? { prototype_value.reg.is_realized }; ];

Section INSTR_CALL, INSTR_STORE

  - find_slot name:CSTRING :SLOT <-
  [ -? {parsed}; ]
  ( + it:ITERATOR(SLOT);
    + res :SLOT;
    
    (it := slots.iterate).loop_v { s:SLOT;
      (s.name = name).if {
        res := s;
        it.stop;
      };
    };
    res
  );

Section CLUSTER, ITM_TYPE, SLOT, INSTR_FNPTR

  - to_type :TYPE <-
  [ -? {defined}; ]
  (
    TYPE.clone.make Self
  );

  - to_type_block :TYPE <-
  [ -? {defined}; ]
  (
    TYPE.clone.make_block Self
  );

Section CLUSTER_ITEM

  - make_file file:CSTRING cluster c:CLUSTER :SELF <-
  (
    expanded := FALSE;
    cluster  := c;
    filename := file;
    ast      := NULL;
    slots    := FAST_ARRAY(SLOT).create 0;
    parser   := PARSER_LI.clone.make Self;
    state    := state_made;
    prototype_value  := EXPR;
    initializer_list := NULL;
    num_compiled_data_slots := 0;
    Self
  );

Section PARSER_LI

  - set_role r:CSTRING <-
  [ -? {made}; -? {! parsed}; ]
  (
    role := r;
    cluster.set_prototype Self for_role r;
  );

  - set_base_type t:BASE_TYPE <-
  [
    -? {made};
    -? {! parsed};
    -? { t != NULL };
  ]
  (
    base_type := t;
  );
  
  - make_expanded :SELF <-
  (
    expanded := TRUE;
    Self
  );

Section SLOT

  + initializer_list :LIST; // TODO: generate

  - add_slot s:SLOT <-
  (
    slots.add_last s;
    ((s.style.plus) && {s.has_result}).if {
      s.set_type_index num_compiled_data_slots;
      num_compiled_data_slots := num_compiled_data_slots + 1;
    };
  );

Section SLOT_BLOCK

  - add_slot_block s:SLOT_BLOCK <-
  (
    slots.add_last s;
  );

Section Private

  + num_compiled_data_slots :INTEGER := 0;

  + state :INTEGER;
  
  - state_none      :INTEGER := 0;
  - state_made      :INTEGER := 1;
  - state_parsed    :INTEGER := 3;
  - state_defined   :INTEGER := 4;
  - state_compiled  :INTEGER := 5;
  - state_linked    :INTEGER := 6;
  - state_generated :INTEGER := 7;

  + parser :PARSER_LI;

  + ast :ITM_PROTOTYPE;

  + slots :FAST_ARRAY(SLOT);


