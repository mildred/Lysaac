Section Header

  + name := PROTOTYPE;

Section Inherit

  + parent_any :Expanded ANY;
  
  - parent_i_find_type :Expanded I_FIND_TYPE;

Section Public

  - made      :BOOLEAN <- state >= state_made;      // Object is made and ready
  - parsed    :BOOLEAN <- state >= state_parsed;    // AST is parsed
  - defined   :BOOLEAN <- state >= state_defined;   // External interfaces are defined
  - compiled  :BOOLEAN <- state >= state_compiled;  // Internal code is compiled
  - generated :BOOLEAN <- state >= state_generated; // Code is generated.

  - find_type type_name:CSTRING :TYPE <- cluster.find_type type_name;
  
  + base_type :BASE_TYPE <-
  [ -? {defined}; ]
  (
    defined.if_false {
      warnln("ERROR !!! PROTOTYPE.base_type is called before the prototype is defined !!!");
    };
    warnln ("PROTOTYPE.base_type " + to_string);
    base_type := BASE_TYPE.create_struct;
    slots.iterate.loop_v { s:SLOT;
      warnln (s.to_string);
      ((s.style.plus) && {s.has_result}).if {
        warnln ("ok");
        base_type.struct_types.add_last (s.result_type.base_type);
      };
    };
    warnln ("PROTOTYPE.base_type " + base_type.to_string);
    base_type
  );
  
  + prototype_value :EXPR;
  
  - void :BOOLEAN <- base_type.void;
  
  + filename :CSTRING;
  
  + role :CSTRING := "";
  
  + cluster :CLUSTER;
  
  + expanded :BOOLEAN;
  
  + name :CSTRING <-
  ( + str :ABSTRACT_STRING;
    
    str := PATH_HELPER.basename filename;
    name := str.substring (str.lower) to (str.upper - 3).as_upper
  );
  
  - parse <-
  [ -? {made}; -? {! parsed}; ]
  ( + e :ERR;
    warnln ("Parse "+name);
    (ast, e) := parser.parse;
    e.assert;
    state := state_parsed;
  )
  [ +? {parsed}; ];
  
  - define_in list:LIST_PROC <-
  [ -? {parsed}; -?{!defined}; ]
  (
    warnln ("Define "+name);
    ast.define_in list;
    state := state_defined;
  )
  [ +? { defined }; ];
  
  - compile <-
  [ -? {defined}; -? {! compiled}; ]
  (
    warnln ("Compile "+name);
    prototype_value := EXPR.clone.make_type to_type;
    state := state_compiled;
  )
  [ +? {compiled}; ];
  
  - generate gen:GENERATOR <-
  [ -? {compiled}; -? {! generated}; ]
  (
    warnln ("Generate "+name);
    slots.iterate.loop_v { s:SLOT;
      s.generate gen;
    };
    state := state_generated;
  )
  [ +? {generated}; ];
  
  - to_string :STRING <- type_name + "<" + name + ">";

Section SLOT

  - generate gen:GENERATOR prototype_value r:REG <-
  (
    prototype_value.reg.is_realized.if_false {
      gen.global_prototype_value prototype_value members {
        slots.iterate.loop_v { s:SLOT;
          ((s.style.plus) && {s.has_result}).if {
            + reg:REG;
            reg := REG.clone.make_type (s.result_type);
            gen.expr_undef_in reg;
            gen.struct_member reg;
          };
        };
      };
    };
    r.realize_using prototype_value;
  )
  [ +? { r.is_realized }; ];

Section INSTR_CALL, INSTR_STORE

  - find_slot name:CSTRING :SLOT <-
  [ -? {parsed}; ]
  ( + it:ITERATOR(SLOT);
    + res :SLOT;
    
    (it := slots.iterate).loop_v { s:SLOT;
      (s.name = name).if {
        res := s;
        it.stop;
      };
    };
    res
  );

Section CLUSTER, ITM_TYPE, SLOT, INSTR_FNPTR

  - to_type :TYPE <-
  [ -? {defined}; ]
  (
    TYPE.clone.make Self
  );

  - to_type_block :TYPE <-
  [ -? {defined}; ]
  (
    TYPE.clone.make_block Self
  );

Section CLUSTER_ITEM

  - make_file file:CSTRING cluster c:CLUSTER :SELF <-
  (
    expanded := FALSE;
    cluster  := c;
    filename := file;
    ast      := NULL;
    slots    := FAST_ARRAY(SLOT).create 0;
    parser   := PARSER_LI.clone.make Self;
    state    := state_made;
    prototype_value := EXPR;
    Self
  );

Section PARSER_LI

  - set_role r:CSTRING <-
  [ -? {made}; -? {! parsed}; ]
  (
    role := r;
    cluster.set_prototype Self for_role r;
  );

  - set_base_type t:BASE_TYPE <-
  [
    -? {made};
    -? {! parsed};
    -? { t != NULL };
  ]
  (
    base_type := t;
  );
  
  - make_expanded :SELF <-
  (
    expanded := TRUE;
    Self
  );

Section SLOT

  - add_slot s:SLOT <-
  (
    slots.add_last s;
  );

Section SLOT_BLOCK

  - add_slot_block s:SLOT_BLOCK <-
  (
    slots.add_last s;
  );

Section Private

  + state :INTEGER;
  
  - state_none      :INTEGER := 0;
  - state_made      :INTEGER := 1;
  - state_parsed    :INTEGER := 3;
  - state_defined   :INTEGER := 4;
  - state_compiled  :INTEGER := 5;
  - state_generated :INTEGER := 6;

  + parser :PARSER_LI;

  + ast :ITM_PROTOTYPE;

  + slots :FAST_ARRAY(SLOT);


