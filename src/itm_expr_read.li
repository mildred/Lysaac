Section Header

  + name := ITM_EXPR_READ;

Section Inherit

  + parent_itm_expr :Expanded ITM_EXPR;

Section Public

  - is_void :BOOLEAN <- FALSE;

  + receiver :ITM_EXPR;
  + slot     :CSTRING;
  
  + arguments :FAST_ARRAY(ITM_EXPR);
  
  - compile_in list:LIST :VAR <-
  [
    ? { list.self.is_valid };
  ]
  ( + self  :VAR;
    + res   :INSTR;
    + local :ITM_EXPR_LOCAL;
    
    ((receiver = NULL) && {(local := lookup_local slot) != NULL}).if {
      res := INSTR_LOAD.clone.make_variable (local.compile_in list);
    } else {
      + call :INSTR_CALL;
      (receiver = NULL).if {
        self := list.self;
      } else {
        self := receiver.compile_in list;
      };
      self.is_null.if {
        warn "Cannot INSTR_CALL, the receiver doesn't have a type ";
        (receiver = NULL).if {
          warnln "(implicit receiver)";
        } else {
          warnln "(explicit receiver)";
        };
        res := INSTR_NOP;
      } else {
        ? {self.type != NULL};
        call := INSTR_CALL.clone.make_itm Self receiver self;
        arguments.iterate.loop_v { a:ITM_EXPR;
          call.add_argument (a.compile_in list);
        };
        res := call;
      };
    };

    res.add_in list.result
  );

Section PARSER
  
  - make s:CSTRING :SELF <-
  (
    slot      := s;
    receiver  := NULL;
    arguments := FAST_ARRAY(ITM_EXPR).create 0;
    Self
  );
  
  - add_argument arg:ITM_EXPR <-
  (
    arg.set_itm_parent Self;
    arguments.add_last arg;
  );
  
  - set_self s:ITM_EXPR <-
  [ -?{ receiver = NULL }; ]
  (
    s.set_itm_parent Self;
    receiver := s;
  );

