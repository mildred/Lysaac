Section Header

  + name := ITM_EXPR_READ;

Section Inherit

  + parent_itm_expr :Expanded ITM_EXPR;

Section Public

  - is_void :BOOLEAN <- FALSE;

  + receiver :ITM_EXPR;
  + slot     :CSTRING;
  
  + has_results :BOOLEAN := TRUE;

  + result   :EXPR := EXPR;
  
  + arguments :FAST_ARRAY(ITM_EXPR);
  
  - compile_in list:LIST :SELF <-
  [
    ? { list.self.is_valid };
  ]
  ( + self      :EXPR;
    + local     :ITM_EXPR_LOCAL;
    
    ((receiver = NULL) && {(local := lookup_local slot) != NULL}).if {
      // Local variable
      result := local.compile_in list.result;
      INSTR_REG.clone.make_variable result.add_in list;
    } else {
      // Slot call
      + call :INSTR_CALL;
      (receiver = NULL).if {
        self := list.self;
      } else {
        self := receiver.compile_in list.result;
      };
      self.reg.is_null.if {
        warn "Cannot INSTR_CALL, the receiver doesn't have a type ";
        (receiver = NULL).if {
          warnln "(implicit receiver)";
        } else {
          warnln "(explicit receiver)";
        };
      } else {
        ? {self.is_valid};
        call := INSTR_CALL.clone.make_itm Self receiver self;
        arguments.iterate.loop_v { a:ITM_EXPR;
          + arg :EXPR;
          warnln ("Argument: " + a.to_string);
          arg := a.compile_in list.result;
          a.has_multiple_results.if {
            a.results.iterate.loop_v { v:EXPR;
              call.add_argument v;
            };
          } else {
            call.add_argument arg;
          };
        };
        call.add_in list;
        call.slot.has_result.if {
          result := EXPR.clone.make (call.result, call.slot.result_type);
        } else {
          has_results := FALSE;
        };
      };
    };

    Self
  );
  
  - to_string :STRING <-
  ( + res :STRING;
    res := type_name + "<";
    (receiver != NULL).if {
      res.append (receiver.to_abstract_string);
      res.add_last '.';
    };
    res.append slot;
    arguments.iterate.loop_v { a:ITM_EXPR;
      res.add_last ' ';
      res.append (a.to_abstract_string);
    };
    res.add_last '>';
    res
  );

Section PARSER
  
  - make s:CSTRING :SELF <-
  (
    slot      := s;
    receiver  := NULL;
    arguments := FAST_ARRAY(ITM_EXPR).create 0;
    Self
  );
  
  - add_argument arg:ITM_EXPR <-
  (
    arg.set_itm_parent Self;
    arguments.add_last arg;
  );
  
  - set_self s:ITM_EXPR <-
  [ -?{ receiver = NULL }; ]
  (
    s.set_itm_parent Self;
    receiver := s;
  );

