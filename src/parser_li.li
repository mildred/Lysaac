Section Header

  + name      := PARSER_LI;

Section Inherit

  + parent_parser :Expanded PARSER;

Section SELF

  + prototype :PROTOTYPE;
  
  + ast :ITM_PROTOTYPE;

  - read_li <-
  (
    read_section_header;
    read_sections;
  );
  
  - hook_header_slot slot:ITM_SLOT <-
  (
    (slot.identifier == "name").if {
      slot.expression.is_a ITM_EXPR_PROTO.if { + p:ITM_EXPR_PROTO;
        p ?= slot.expression;
        (p.prototype.as_lower == prototype.name).if_false {
          print_warning;
          "expected ".print; prototype.name.as_upper.println;
        };
      } else {
        print_warning;
        "expected prototype constant".println;
      };
    }.elseif {slot.identifier == "role"} then {
      slot.expression.is_void.if_false {
        print_warning;
        "expected void expression".println;
      };
      slot.has_keyword "String".if {
        + p :PROTOTYPE;
        p := prototype.cluster.prototype_for_role "String";
        (p = NULL).if {
          prototype.cluster.set_prototype prototype role "String";
        } else {
          prototype.cluster.set_prototype NULL role "String";
          print_warning;
          "There is already a prototype with the role ".print; "String".print;
          " in ".print; p.filename.println;
        };
      };
    } else {
      print_warning;
      "unknown slot ".print; slot.identifier.println;
    };
  );

  - handle_slot slot:ITM_SLOT <-
  (
    ast.add_slot slot;
  );

Section PROTOTYPE

  - make p:PROTOTYPE :SELF <-
  (
    prototype := p;
    ast := ITM_PROTOTYPE.clone.make;
    Self
  );
  
  - parse :ITM_PROTOTYPE <-
  (
    open_source (prototype.filename);
    read_li;
    ast
  );
