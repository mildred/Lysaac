Section Header

  + name := SLOT;

Section Inherit

  + parent_proc :Expanded PROC;

Section Public

  - name :CSTRING <- ast.identifier;
  
  - external :BOOLEAN <- ast.is_external;
  
  - export :BOOLEAN <- ast.is_export;
  
  - external_or_export :BOOLEAN <- (external) || {export};
  
  + external_name :CSTRING <- name;
  
  + arguments :FAST_ARRAY(REG);
  
  + prototype :PROTOTYPE;

  + self :EXPR;
  
  + result_type :TYPE;
  
  - style :ITM_STYLE <- ast.style;
  
  - has_result :BOOLEAN <- (result_type != NULL);
  
  - to_string :STRING <-
  ( + res:STRING;
    res := type_name + "<" + name;
    (result_type != NULL).if {
      res.append (":" + result_type.to_string + ">");
    };
    res.append ">";
    res
  );
  
  - is_compiled_data_slot :BOOLEAN <- type_index >= 0;
  
  + type_index :INTEGER := -1;
  
  - position :POS <- ast.position;

Section Private

  + list :LIST;

Section PROTOTYPE

  + default_value :EXPR;

Section ITM_SLOT

  - make s:ITM_SLOT :SELF <-
  (
    make_error_collector ("slot " + s.identifier);
    arguments := FAST_ARRAY(REG).create 0;
    list          := NULL;
    ast           := s;
    prototype     := ast.prototype_parent;
    default_value := EXPR;
    self          := EXPR;
    type_index    := -1;
    ? {prototype != NULL};
    Self
  );
  
  - add_argument v:REG <- arguments.add_last v;
  
  - set_return_type t:TYPE <-
  (
    default_value := EXPR.clone.make_type t;
    result_type := t;
  );
  
  - finish_creation <-
  (
    prototype.add_slot Self;
  );

Section LIST_PROC

  - compile list_procs:LIST_PROC <-
  ( + t:TYPE;
    t := prototype.to_type;
    t.void.if {
      self := EXPR;
    } else {
      self := EXPR.clone.make_type t;
    };
    ? { self.is_valid };
    list := LIST.clone.make_self self.make_error_collector Self type result_type;
    external.if {
      // External Slot
      + sym :ITM_EXPR_SYM;
      sym ?= ast.expression;
      ? { sym != NULL };
      external_name := sym.symbol;
    } else {
      list.set_list_procs list_procs;
      prototype.initializer_list.set_list_procs list_procs;
      compile_initializer;
      compile_slot;
    };
  );

Section Private

  - compile_initializer <-
  [ -? {! external}; ]
  (
    (is_compiled_data_slot && {ast.affect.data}).if {
      INSTR_STORE
        .clone
        .make_slot Self
          receiver (prototype.initializer_list.self)
          value (ast.expression.compile_in (prototype.initializer_list).result)
        .add_in (prototype.initializer_list);
    };
  );

  - compile_slot <-
  [ -? {! external}; ]
  (
    (is_compiled_data_slot && {ast.affect.data}).if {
      // Read data slot
      list.add_result (INSTR_LOAD
        .clone
        .make_slot Self receiver (list.self) list list
        .add_in list
        .result);
    }.elseif {ast.expression != NULL} then {
      // Nominal case
      ast.expression.compile_in list;
      ast.expression.err.failure.if {
        add_error(error(ast.expression.err, ast.position, "Dropping return value #1 for slot " + name));
      } else {
        (ast.expression.result.type = result_type).if {
          list.add_result (ast.expression.result.reg);
        }.elseif {has_result} then {
          add_error(error(ERR, ast.expression.position,
            "Incompatible type for return value #1. "
            + "Got: " + pretty_type(ast.expression.result.type)
            + ", expected: " + pretty_type(result_type)));
        };
      };
    } else {
      // Empty slot
    };
    ((has_result) && {list.results.is_empty}).if {
      add_error(error(ERR, ast.position,
        "No value given for this slot. Using prototype "
        + pretty_type(result_type)));
      list.add_result (result_type.prototype.compile_prototype_value_in list);
    };
    export.if {
      prototype_self := prototype.compile_prototype_value_in list;
    };
  );

Section LIST_PROC

  - link <-
  (
    external.if_false {
      list.link;
    };
  );
  
  - generate gen:GENERATOR <-
  (
    external.if {
      gen.declare_sub external_name args {
        arguments.iterate.loop_v { v:REG;
          gen.arg { v.base_type.generate gen; };
        };
      };
    } else {
      generate_slot gen;
    };
  );

Section Private

  - generate_slot gen:GENERATOR <-
  [
    -? {! external};
    -? { ! self.reg.is_realized };
  ]
  (
    list.assert_result_coherent_with(result_type);

    gen.sub external_name self self args {
      export.if_false {
        self.reg.generate_arg gen;
      };
      arguments.iterate.loop_v { v:REG;
        v.generate_arg gen;
      };
    } do {
      export.if {
        ? { prototype_self != NULL };
        self.reg.realize_using (prototype_self);
      };
      ? { self.reg.is_realized };
      is_block_value_slot.if {
        gen.call_ptr (list.self);
      } else {
        list.generate gen;
      };
    } return (list.first_result_or_invalid);
  );

Section PROTOTYPE

  - set_type_index i:INTEGER <-
  [ -? {i >= 0}; ]
  (
    type_index := i;
  )
  [ +? {is_compiled_data_slot}; ];

Section Private

  - is_block_value_slot :BOOLEAN <-
  ( (prototype.role == "Block") &&
    {ast.has_keyword "Internal"} &&
    {ast.has_keyword "Value"}
  );

  + ast :ITM_SLOT;
  
  + prototype_self :EXPR;


