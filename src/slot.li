Section Header

  + name := SLOT;

Section Inherit

  + parent_proc :Expanded PROC;

Section Public

  //////////////////////////////////////////////////////////////////////////////
  //
  // Identification
  //

  - name :CSTRING <- (deferred; NULL);
  // User-friendly name
  
  + external_name :CSTRING <-
  // Symbol name
  ( 
    (export | external).if {
      external_name := name;
    } else {
      external_name := symbol_encode_prototype self_prototype slot Self;
    };
    external_name
  );
  
  - style   :ITM_STYLE <- deferred;
  
  - external  :BOOLEAN <- deferred;
  - export    :BOOLEAN <- deferred;
  - internal  :BOOLEAN <- deferred;
  
  - shared    :BOOLEAN <- style.minus;
  
  - slot_data :BOOLEAN <- deferred;
  - slot_code :BOOLEAN <- (! slot_data);
  
  //////////////////////////////////////////////////////////////////////////////
  //
  // Location
  //
  
  - root_prototype :PROTOTYPE <- self_prototype;
  // Prototype in which the slot is first defined
  
  + self_prototype :PROTOTYPE;
  // Prototype SELF, of the synamic type
  
  - prototype :PROTOTYPE <- self_prototype;
  
  //////////////////////////////////////////////////////////////////////////////
  //
  // Signature
  //
  
  - result_type :TYPE <- (deferred; NULL);
  
  - has_result :BOOLEAN <- (result_type != NULL);
  
  //////////////////////////////////////////////////////////////////////////////
  //
  // Implementation
  //
  
  - internal_opcode :CSTRING <- (deferred; NULL);
  
  + arguments :FAST_ARRAY(EXPR);

  + self :EXPR;
  
  + type_index :INTEGER := -1;

  //////////////////////////////////////////////////////////////////////////////
  //
  // Debug
  //
  
  - to_string :STRING <-
  ( + res:STRING;
    res := type_name + "<" + name;
    (result_type != NULL).if {
      res.append (":" + result_type.to_string + ">");
    };
    res.append ">";
    res
  );
  
  - position :POS <- (deferred; POS);

Section Private

  //////////////////////////////////////////////////////////////////////////////
  //
  // Private Interface
  //
  
  + self_prototype_expr :EXPR;

  + list :LIST;

Section SLOT

  - ast_expression :ITM_EXPR <- (deferred; NULL);

Section ITM_EXPR_WRITE

  + shared_data_variable :REG;
  // Register for shared slot (style '-')

Section PROTOTYPE

  + default_value :EXPR <-
  (
    (result_type = NULL).if {
      default_value := EXPR;
    } else {
      default_value := EXPR.clone.make_type result_type;
    };
    default_value
  );

  - set_type_index i:INTEGER <-
  [ -? {i >= 0}; ]
  (
    type_index := i;
  );

  //////////////////////////////////////////////////////////////////////////////
  //
  // Compilation
  //

Section LIST_PROC

  - compile list_procs:LIST_PROC <-
  ( + t:TYPE;
    t := self_prototype.to_type_reference;
    t.void.if {
      self := EXPR;
    } else {
      self := EXPR.clone.make_type t;
    };
    ? { self.is_valid };
    ? { self.type.reference };
    list := LIST.clone.make_self self.make_error_collector Self type result_type;
    external.if {
      // External Slot
      + sym :ITM_EXPR_SYM;
      sym ?= ast_expression;
      ? { sym != NULL };
      external_name := sym.symbol;
    } else {
      ((shared) && {slot_data}).if {
        shared_data_variable := REG.clone.make_type
          (BASE_TYPE.create_pointer(result_type.to_impl.base_type));
      };
      list.set_list_procs list_procs;
      self_prototype.initializer_list.set_list_procs list_procs;
      compile_initializer;
      compile_slot;
    };
  );

Section Private

  - compile_initializer <-
  [ -? {! external}; ]
  ( + r:REG;
    slot_data.if {
      ast_expression.compile_in (self_prototype.initializer_list);
      ast_expression.results.failure.if {
        add_error (ast_expression.results.err);
      }.elseif {ast_expression.results.is_empty} then {
        add_error (position.error("Missing initial value"));
      } else {
        (!ast_expression.results.is_single).if {
          add_error (position.error("Dropping the last " + (ast_expression.results.count - 1).to_string + " values"));
        }.elseif {shared} then {
          r := shared_data_variable;
        } else {
          r := INSTR_GETELEMPTR
            .clone
            .make (self_prototype.initializer_list.self) slot Self
            .add_in (self_prototype.initializer_list)
            .result;
        };
        INSTR_STORE
          .clone
          .make_store_in r
            value (ast_expression.results.first)
          .add_in (self_prototype.initializer_list);
      };
    };
  );

  - compile_slot <-
  [ -? {! external}; ]
  (
    (internal).if {
      compile_opcode_in list;
    }.elseif {slot_data} then {
      // Read data slot
      shared.if {
        list.add_result (INSTR_LOAD
          .clone
          .make shared_data_variable
          .add_in list
          .result);
      } else {
        list.add_result (INSTR_LOAD
          .clone
          .make_slot Self receiver (list.self) list list
          .add_in list
          .result);
      };
    }.elseif {ast_expression != NULL} then {
      // Nominal case
      
      + exprs :EXPRS;
      exprs := ast_expression.compile_in list.results;
      
      exprs.failure.if {
        add_error(exprs.err.extend(position, "Dropping return value #1 for slot " + name));
      }.elseif {! exprs.is_empty} then {
        exprs.is_single.if_false {
          add_error(position.error("Only keep the first return value"));
        };
        (exprs.first.type = result_type).if {
          list.add_result (exprs.first.reg);
        }.elseif {has_result} then {
          add_error(ast_expression.position.error(
            "Incompatible type for return value #1. "
            + "Got: " + pretty_type(exprs.first.type)
            + ", expected: " + pretty_type(result_type)));
        };
      };
    } else {
      // Empty slot
    };
    ((has_result) && {list.results.is_empty}).if {
      add_error(position.error(
        "No value given for this slot. Using prototype "
        + pretty_type(result_type)));
      list.add_result (result_type.to_impl.prototype.compile_prototype_value_in list);
    };
    export.if {
      self_prototype_expr := self_prototype.compile_prototype_value_in list;
    };
  );
  
  - compile_opcode_in list:LIST <-
  [
    -? { internal_opcode != NULL };
  ]
  (
    (internal_opcode == "object_size").if {
      list.add_result (INSTR_SIZEOF
        .clone
        .make (self.type.to_impl.prototype.base_type)
        .add_in list
        .result);
    }.elseif {internal_opcode == "value"} then {
      INSTR_CALL
        .clone
        .make_ptrcall (list.self) of Self
        .finalize_in list
        .if_fail { e:ERR;
          add_error(e.extend(position, "Calling the block"));
        };
    } else {
      add_error(position.error("Unknown opcode " + internal_opcode));
    }
  );

Section LIST_PROC

  //////////////////////////////////////////////////////////////////////////////
  //
  // Link
  //

  - link gen:GENERATOR <-
  (
    external.if_false {
      ((slot_data) && {shared}).if {
        gen.alloc_global shared_data_variable;
      };
      list.link gen;
    };
  );

  //////////////////////////////////////////////////////////////////////////////
  //
  // Generation
  //
  
  - generate gen:GENERATOR <-
  (
    external.if {
      gen.declare_sub external_name args {
        arguments.iterate.loop_v { v:EXPR;
          gen.arg { v.reg.base_type.generate gen; };
        };
      } return {
        (result_type = NULL).if {
          gen.type_void;
        } else {
          result_type.to_impl.base_type.generate gen;
        };
      };
    } else {
      ((slot_data) && {shared}).if {
        gen.global_variable shared_data_variable;
      };
      generate_slot gen;
    };
  );

Section Private

  - generate_slot gen:GENERATOR <-
  [
    -? {! external};
    -? { ! self.reg.is_realized };
  ]
  (
    list.assert_result_coherent_with(result_type);

    gen.sub external_name self self args {
      export.if_false {
        self.reg.generate_arg gen;
      };
      arguments.iterate.loop_v { v:EXPR;
        v.reg.generate_arg gen;
      };
    } do {
      export.if {
        ? { self_prototype_expr != NULL };
        self.reg.realize_using (self_prototype_expr);
      };
      ? { self.reg.is_realized };
      list.generate gen;
    } return (list.first_result_or_invalid);
  );


