Feature: Dispatching of booleans

  The compiler manages different inheritance trees. These trees cannot mix.
  Multiple inheritance is accepted only if the two types have the same common
  root. This is easily managed using a super object OBJECT.
  
  BOOLeans have a separate inheritance tree suited for their use.
  
  Inheritance is based upon the Dispatch slot. The Dispatch slot is a slot with:
  
   -  a style `+`
   -  only data affectations `:=` allowed (or none, in which case the
      affectation is generated by the compiler). Only integer constants are
      allowed
   -  only a Strict type allowed
   -  Once assigned, the value of the Dispatch slot can never be changed.
  
  Multiple inheritance is allowed with the restriction that a single root for
  the inheritance tree is allowed. In practice, all objects, and even
  interfaces, inherit from `OBJECT` (except `BOOL`eans). The tree root must
  define a Dispatch slot. The Dispatch slot might be redefined by the children.
  
  This restriction is necessary because the root type is the one which will
  define how the dispatching is done.
  
  When trying to determine the dynamic type of a value, differents checks are
  made:
  
   -  First, the Dispatch slot is loaded. If its value is equals to an unique
      known (of the same cluster) direct child type, then this type is the
      dynamic type.
  
   -  If this fails, the  lookup is made with the known (of the same cluster)
      grand-children of the static type. If this fails again, the check
      continues with the next generation, until exhaustion of the known
      inheritance tree.

   -  If this fails, or if there is ambiguity at any of the above steps, the
      type of the Dispatch slot is considered. if the type has a Dispatcher
      slot, this slot is called. The Dispatcher slot is called with Self and the
      identifier of the slot required. The slot identifiers are available as
      public integer constants resolvable at link-time through a symbolic name.
      The function then calls the slot and return its result. Extra arguments
      are passed as vararg. (If it is possible with LLVM)
  
  In case the value for the Dispatch slot is not defined, the compiler shall
  generate a suitable value for this slot. The value would be an object that
  responds to the Dispatcher slot correctly. The exact means are not yet defined
  and probably further restrictions would be made on the type of the Dispatch
  slot in that case.

  @wip
  Scenario:
    Given the following prototypes in "c":
      | Prototype |
      | BLOCK     |
      | CSTRING   |
      | INT32     |
      | BIT       |
      | BOOL      |
      | TRUE      |
      | FALSE     |
      And a file "c/main.li" with
      """
      Section Header
        
        + name := MAIN;
        
      Section Public
      
        - puts (format:CSTRING) <- External `puts`;
        
        - test b:BOOL <-
        (
          b.if {
            puts("This is TRUE");
          }.else {
            puts("This is FALSE");
          }
          .if_true  { puts "TRUE"; }
          .if_false { puts "FALSE"; };
        );
      
        - main <- Export
        (
          test FALSE;
          test TRUE;
          test FALSE;
        );
      
      """
     When I execute the cluster "c"
     Then I should see
      """
      This is FALSE
      FALSE
      This is TRUE
      TRUE
      This is FALSE
      FALSE
      
      """
