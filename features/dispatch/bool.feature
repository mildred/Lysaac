Feature: Dispatching of booleans

  The compiler manages different inheritance trees. These trees cannot mix.
  Multiple inheritance is accepted only if the two types have the same common
  root. This is easily managed using a super object OBJECT.
  
  BOOLeans have a separate inheritance tree suited for their use.
  
  There are two kind of dispatching available:
  
   -  Automatic dispatching through a dispatching function generated by the
      compiler. Its pointer is included in the object to be dispatched as a
      `Dispatcher` slot styleed with `+` or `-`. If the style is `-` (shared),
      it restrict the inheritance to same cluster prototypes.

   -  Manual dispatching using a `Dispatcher` code slot styled with `-` (shared)
      specified in the root of the inheritance tree. This special `Dispatcher`
      slot has access to only the `Dispatch` data slots defined in the same
      prototype. This method still requires thinking.
  
  With these information, we can easily infer a simple rule: **It is possible to
  inherit only from objects that have a `Dispatcher` slot defined, either
  directly or through inheritance. it is not possible to inherit from two
  different types if their `Dispatcher` slot is not the same.**
  
  In case of automatic dispatching using a shared slot (style `-`), another slot
  with the keyword `Dispatch` and styled `+` must be defined. It must be of an
  integer type and associated with a constant integer value (or no value at
  all). Its value cannot be changed in the future. The dispatcher function uses
  this slot to determine the dynamic type of the object:
  
  There are two forms for the `Dispatcher` slot. Manual dispatching:
  
   -  First, the Dispatch slot is loaded. If its value is equals to an unique
      known (of the same cluster) direct child type, then this type is the
      dynamic type.
  
   -  If this fails, the  lookup is made with the known (of the same cluster)
      grand-children of the static type. If this fails again, the check
      continues with the next generation, until exhaustion of the known
      inheritance tree.
   
   -  At exhaustion, the type considered is the root of the hierarchy.

  @wip
  Scenario:
    Given the following prototypes in "c":
      | Prototype |
      | BLOCK     |
      | CSTRING   |
      | INT32     |
      | BIT       |
      | BOOL      |
      | TRUE      |
      | FALSE     |
      And a file "c/main.li" with
      """
      Section Header
        
        + name := MAIN;
        
      Section Public
      
        - puts (format:CSTRING) <- External `puts`;
        
        - test b:BOOL <-
        (
          b.if {
            puts("This is TRUE");
          }.else {
            puts("This is FALSE");
          }
          .if_true  { puts "TRUE"; }
          .if_false { puts "FALSE"; };
        );
      
        - main <- Export
        (
          test FALSE;
          test TRUE;
          test FALSE;
        );
      
      """
     When I execute the cluster "c"
     Then I should see
      """
      This is FALSE
      FALSE
      This is TRUE
      TRUE
      This is FALSE
      FALSE
      
      """
